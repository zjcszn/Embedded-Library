<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: Event Memory Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="ql-preview.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="ql-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.png"/></a>
  </div>
   <div id="projectname">
    QP/C
    &nbsp;<span id="projectnumber">7.3.4</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('srs_emm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Event Memory Management</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><span class="prev_button"><a class="el" href="srs_edm.html">Event Delivery Mechanisms</a></span><span class="next_button"><a class="el" href="srs_tm.html">Time Management</a></span> </p>
<h1><a class="anchor" id="srs_emm-def"></a>
Concepts &amp; Definitions</h1>
<p>In any event-driven system, events are frequently passed from producers to consumers. The events passed around can be either <a class="el" href="srs_emm.html#src_emm-imm">immutable</a> or <a class="el" href="srs_emm.html#srs_emm-mut">mutable</a>.</p>
<h2><a class="anchor" id="src_emm-imm"></a>
Immutable Events</h2>
<p><b>Immutable events</b> are event instances that never change at runtime. Such immutable events can be pre-allocated statically (typically and preferably in ROM) and can be <b>shared safely</b> among any number of concurrent entities (Active Objects, ISRs, "naked" threads, etc.) rather than being created and recycled dynamically every time. QP Framework does not need to manage memory for immutable events, but needs to clearly distinguish them from <a class="el" href="srs_emm.html#srs_emm-mut">mutable events</a>, precisely to <em>avoid</em> any memory management for them.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Immutability is a desirable property of events because exchanging such events is faster and safer compared to <a class="el" href="srs_emm.html#srs_emm-mut">mutable events</a> described below.</dd></dl>
<h2><a class="anchor" id="srs_emm-mut"></a>
Mutable Events</h2>
<p>Many event instances, especially <a class="el" href="srs_evt.html#srs_evt-par">events with parameters</a> cannot be easily made immutable because their main function is specifically to deliver information produced at <em>runtime</em>. Consequently, such <b>mutable events</b> must be dynamically created and recycled at runtime, and management of that process is one of the most valuable services QP Framework can provide to QP Application.</p>
<p>The main challenge of managing mutable events is to guarantee that once a mutable event gets posted or published (which might involve event multicasting), it does not change and does not get recycled until all Active Objects have finished their <a class="el" href="srs_ao.html#srs_ao-rtc">Run-to-Completion</a> processing of that event. In fact, changing or premature recycling the <a class="el" href="srs_ao.html#srs_ao-curr">current event</a> constitutes a violation of the RTC semantics. A flip side aspect of the memory management issue is timely and deterministic recycling of mutable events that are no longer in use, so that the memory (precious RAM) can be reused as soon as possible. Finally, the memory management must also carefully avoid <em>concurrency hazards</em> around the shared mutable events. Failure in any of those aspects results in defects (bugs) that are the hardest to detect, isolate, and fix.</p>
<h2><a class="anchor" id="src_emm-zero"></a>
Zero-Copy Event Management</h2>
<p>From the safety point of view, the ideal would be to <em>copy</em> entire mutable events into and out of the event queues, as it is often done with the message queues of a traditional RTOS. Unfortunately, it is prohibitively expensive in RAM and nondeterministic in CPU cycles for larger event instances (events with large parameters). However, an event-driven framework, like QP, can be far more sophisticated than a traditional RTOS because, due to <a class="el" href="srs_ao.html#srs_ao-inv">inversion of control</a>, the framework manages an event's <em>whole life cycle</em>. The framework extracts an event from the Active Object's event queue and dispatches it for processing. After the <a class="el" href="srs_ao.html#srs_ao-rtc">Run-to-Completion processing</a>, the framework <em>regains control</em> of the event and can <b>automatically recycle the event</b>.</p>
<p>An event-driven framework can also easily control the dynamic allocation of mutable events (e.g., the QP framework provides API for this purpose). All this permits the framework to implement controlled, concurrency-safe sharing of mutable events, which, from the application standpoint, is almost indistinguishable from copying entire events. Such event management is called <b>zero-copy event management</b>.</p>
<h2><a class="anchor" id="src_emm-ownership"></a>
Mutable Event Ownership Rules</h2>
<p>The zero-copy event delivery mechanisms are designed to be intuitive and transparent to the application-level code. Even so, as with every non-trivial abstraction, <em>zero-copy event management</em> is subject to "The Law of Leaky Abstractions" <a class="el" href="srs.html#srs_ref">[Spolsky-02]</a>. In the case of the <em>zero-copy</em> abstraction, this means that for it to behave exactly like copying, QP Application needs to obey specific event ownership rules similar to the rules of working with objects allocated with the C++ operator <code>new</code> and summarized in the life cycle diagram of a mutable event (see <a class="el" href="srs_emm.html#srs_fig-51">Figure SRS-51</a>). In exchange, QP Framework can safely and deterministically deliver your mutable events with hard real-time performance, which does not complicate the RMS/RMA method and is superior to the copying entire events approach.</p>
<p><a class="anchor" id="srs_fig-51"></a></p><div class="image">
<object type="image/svg+xml" data="evt_life.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SRS-51: Mutable Event Life Cycle and Ownership Rules</em></center></div><p><a class="el" href="srs_emm.html#srs_fig-51">Figure SRS-51</a> illustrates the mutable event life cycle and possible transfers of ownership rights to the event:</p>
<p><code>[0]</code> All mutable events are initially owned by QP framework.</p>
<p><code>[1]</code> An event producer might gain ownership of a new event only by calling the <code>Q_NEW</code> operation. At this point, the producer gains the ownership rights with the permissions to <b>write</b> to the event. Indeed, the purpose of this stage in the mutable event's life cycle is to initialize the event and fill it with data. The event producer might keep the event as long as it needs. For example, the producer (e.g., ISR) might fill the event with data over many invocations. Eventually, however, the producer must transfer the ownership back to the framework.</p>
<p><code>[2a,2b,2c]</code> Typically the producer posts <code>[2a]</code> or publishes <code>[2b]</code> the event. As a special case, the producer might decide that the event is not good, in which case the producer must <em>explicitly</em> recycle <code>[2c]</code> the event. After any of these three operations, the producer immediately loses ownership of the event and can no longer access it. In particular, it is illegal to post, publish, or recycle the event again.</p>
<p><code>[3]</code> The recipient Active Object gains ownership of the <a class="el" href="srs_ao.html#srs_ao-curr">current event</a> upon the start of the RTC step. This time, the Active Object gains the <b>read-only</b> permissions to the <em>current event</em>.</p>
<p><code>[4a,4b]</code> During the RTC step, the recipient Active Object is allowed to re-post <code>[4a]</code> or re-publish <code>[4b]</code> the <em>current event</em> any number of times without losing ownership of the event.</p>
<p><code>[5a]</code> As a special case, the recipient Active Object may defer the current event. Event deferral extends the read-only ownership rights beyond the current RTC step.</p>
<p><code>[5b]</code> Eventually, however, the deferred event must be recalled, which self-posts the event into the Active Object's event queue (using the LIFO policy). Recalling ends the ownership of the original deferred event.</p>
<p><code>[6]</code> The end of the RTC step terminates the ownership of the <em>current event</em>. The Active Object cannot use the event in any way past the RTC step. In particular, if any data from that event is needed in the future, QP Application must save that data (typically in some attributes inside the Active Object).</p>
<h2><a class="anchor" id="src_emm-pools"></a>
Event Pools</h2>
<p>To manage the memory for mutable events, QP Framework needs deterministic, efficient, and concurrency-safe method of dynamically allocating and recycling the memory. The general-purpose, variable-block-size heap does not fit this bill and is inappropriate for safety-related applications, anyway. However, simpler, higher-performance, and <em>safer</em> options exist to the general-purpose heap. A well-known alternative, commonly supported by RTOSs, is a fixed-block-size heap, also known as a memory partition or <b>memory pool</b>. Memory pools are a much better choice for a real-time framework like QP to manage mutable event memory than the general-purpose heap. Unlike the conventional (variable-block-size) heap, a memory pool is deterministic, has guaranteed capacity, and is not subject to fragmentation because all blocks are exactly the same size.</p>
<p>The most obvious drawback of a memory pool is that it does not support variable-sized blocks. Consequently, the blocks have to be oversized to handle the biggest possible allocation. Such a policy is often too wasteful if the actual sizes of allocated objects (mutable events, in this case) vary a lot. A good compromise is often to use not one but <em>multiple</em> memory pools with memory blocks of different sizes. QP Framework chooses that option to implement <b>event pools</b>, which are multiple memory pools specialized to hold mutable events.</p>
<h1><a class="anchor" id="src_emm-req"></a>
Requirements</h1>
<p><a id="a65_REQ-QP-05_00" name="a65_REQ-QP-05_00"></a> </p>
<h2><a class="anchor" id="REQ-QP-05_00"></a>
REQ-QP-05_00</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-05_00 </th></tr>
<tr style="text-align:left">
<th>QP Framework shall support immutable events. </th></tr>
<tr>
<td><b>Description</b><br  />
 Support for immutable events means that QP Framework shall recognize and distinguish them from mutable events. QP Framework should never attempt to manage immutable events as mutable. </td></tr>
<tr>
<td><b>Use Case</b><br  />
 QP Framework can fulfill this requirement by embedding a unique immutable-event signature in the internal data of the event (see <a class="el" href="srs_evt.html#REQ-QP-01_31">REQ-QP-01_31</a>). </td></tr>
</table>
<p><a id="a66_REQ-QP-05_10" name="a66_REQ-QP-05_10"></a> </p>
<h2><a class="anchor" id="REQ-QP-05_10"></a>
REQ-QP-05_10</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-05_10 </th></tr>
<tr style="text-align:left">
<th>QP Framework shall support mutable events. </th></tr>
<tr>
<td><b>Description</b><br  />
 Support for mutable events means that QP Framework shall provide deterministic <b>event pools</b> as well as mechanisms to allocate and recycle mutable events from these pools. Among others, this means that each mutable event instance must "remember" which pool it came from, so that QP Framework can recycle the event to the same pool. </td></tr>
</table>
<p><a id="a67_REQ-QP-05_20" name="a67_REQ-QP-05_20"></a> </p>
<h2><a class="anchor" id="REQ-QP-05_20"></a>
REQ-QP-05_20</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-05_20 </th></tr>
<tr style="text-align:left">
<th>QP Framework shall provide a method of allocating mutable events at runtime. </th></tr>
<tr>
<td><b>Description</b><br  />
 The method of allocating mutable events from an appropriate event pool shall be available to all event producers, such as Active Objects, but also ISRs, "device drivers", or "naked" thread of an RTOS (if a traditional RTOS is used). </td></tr>
</table>
<p><a id="a68_REQ-QP-05_21" name="a68_REQ-QP-05_21"></a> </p>
<h2><a class="anchor" id="REQ-QP-05_21"></a>
REQ-QP-05_21</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-05_21 </th></tr>
<tr style="text-align:left">
<th>Mutable event allocation shall be <u>reliable</u>. </th></tr>
<tr>
<td><b>Description</b><br  />
 "Reliable" event allocation means that QP Framework shall detect if the mutable event cannot be allocated (due to depletion of an event pool). In case allocation fails, QP Framework shall enter a fail-safe state. </td></tr>
</table>
<p><a id="a69_REQ-QP-05_22" name="a69_REQ-QP-05_22"></a> </p>
<h2><a class="anchor" id="REQ-QP-05_22"></a>
REQ-QP-05_22</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-05_22 </th></tr>
<tr style="text-align:left">
<th>QP Framework may provide alternative <u>unreliable</u> method of allocating mutable events. </th></tr>
<tr>
<td><b>Description</b><br  />
 The alterative, unreliable method of allocating mutable events must use a different API than the default reliable event allocation. QP Framework still shall detect that a mutable event cannot be allocated, but the framework should pass this information to QP Application instead of entering a fail-safe state. </td></tr>
</table>
<p><a id="a70_REQ-QP-05_30" name="a70_REQ-QP-05_30"></a> </p>
<h2><a class="anchor" id="REQ-QP-05_30"></a>
REQ-QP-05_30</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-05_30 </th></tr>
<tr style="text-align:left">
<th>QP Framework shall provide a method of recycling mutable events at runtime. </th></tr>
<tr>
<td><b>Description</b><br  />
 The method of recycling mutable events back to the appropriate event pool shall be available to all event producers, such as Active Objects, but also ISRs, "device drivers", or "naked" thread of an RTOS (if a traditional RTOS is used). </td></tr>
</table>
<p><a id="a71_REQ-QP-05_40" name="a71_REQ-QP-05_40"></a> </p>
<h2><a class="anchor" id="REQ-QP-05_40"></a>
REQ-QP-05_40</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-05_40 </th></tr>
<tr style="text-align:left">
<th>QP Framework shall manage mutable events according to the "zero-copy" memory management policy. </th></tr>
<tr>
<td><b>Description</b><br  />
 </td></tr>
</table>
<p><span class="prev_button"><a class="el" href="srs_edm.html">Event Delivery Mechanisms</a></span><span class="next_button"><a class="el" href="srs_tm.html">Time Management</a></span>  </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="srs.html">Software Requirements Specification</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2024 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 7.3.4</b> &nbsp;|&nbsp; Updated on Thu Mar 21 2024
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2024 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 7.3.4</b> &nbsp;|&nbsp; Updated on Thu Mar 21 2024
</small></address>
    </li>
  </ul>
</div>
</body>
</html>
