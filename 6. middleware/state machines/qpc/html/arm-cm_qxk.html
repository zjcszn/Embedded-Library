<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: Preemptive &quot;Dual-Mode&quot; QXK Kernel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="ql-preview.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="ql-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.png"/></a>
  </div>
   <div id="projectname">
    QP/C
    &nbsp;<span id="projectnumber">7.3.4</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('arm-cm_qxk.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Preemptive "Dual-Mode" QXK Kernel</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section describes how to use QP/C on ARM Cortex-M with the <a class="el" href="srs_qxk.html">preemptive, dual-mode QXK real-time kernel</a>, which combines the lightweight non-blocking <a class="el" href="srs_qxk.html#srs_qxk-basic">basic threads</a> of <a class="el" href="struct_q_k.html" title="QK preemptive non-blocking kernel (QK namespace emulated as a &quot;class&quot; in C)">QK</a> with traditional blocking <a class="el" href="srs_qxk.html#srs_qxk-ext">extended threads</a> found in conventional RTOS kernels. <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> provides all typical services of a conventional blocking RTOS, such as blocking time-delays, semaphores, mutextes, and message queues.</p>
<p><a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> has been designed specifically for mixing event-driven active objects with traditional blocking code, such as commercial middleware (TCP/IP stacks, UDP stacks, embedded file systems, etc.) or legacy software.</p>
<dl class="section note"><dt>Note</dt><dd>If you are currently using QP/C on top of a conventional 3rd-party RTOS, consider moving your application to the <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> kernel. <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> is not only more efficient than running QP/C on top of a <a class="el" href="ports_rtos.html">traditional 3rd-party RTOS</a> (because non-blocking <a class="el" href="srs_qxk.html#srs_qxk-basic">basic threads</a> take far less stack space and CPU cycles for context switch than the much heavier <a class="el" href="srs_qxk.html#srs_qxk-ext">extended threads</a>). But the biggest advantage of <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> is that it <b>protects</b> the application-level code from inadvertent mixing of blocking calls inside the event-driven active objects. Specifically, <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> "knows" the type of the thread context (extended/basic) and asserts internally if a blocking call (e.g., semaphore-wait or a time-delay) is attempted in a basic thread (active object). This is something that a QP/C port to a <a class="el" href="ports_rtos.html">conventional 3rd-party RTOS</a> cannot do, because such an RTOS runs all code (including active objects) in the context of heavyweight extended threads.</dd></dl>
<p><b>Synopsis of the <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> Port on ARM Cortex-M</b><br  />
 The preemptive, blocking <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> kernel works on ARM Cortex-M as follows:</p>
<ul>
<li>The ARM Cortex-M processor executes application code in the Privileged Thread mode, which is exactly the mode entered out of reset. The exceptions (including all interrupts) are always processed in the Privileged Handler mode.</li>
<li><a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> uses the Main Stack Pointer (MSP) for <a class="el" href="srs_qxk.html#srs_qxk-basic">basic threads</a>, interrupts and exceptions (such as the PendSV exception). The MSP is also used for the <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> idle thread (which is a non-blocking basic thread).</li>
<li><a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> uses the Process Stack Pointer (PSP) for handling <a class="el" href="srs_qxk.html#srs_qxk-ext">extended threads</a>. Each extended thread must provide a private stack space to be associated with the PSP.</li>
<li>The <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> port uses the <code>PendSV</code> (exception number 14) and the NMI or the IRQ exception (number 2) to perform context switch. The application code (your code) must initialize the Interrupt Vector Table with the addresses of the <code>PendSV_Handler</code> and <code>NMI_Handler</code> exception handlers.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> uses only the CMSIS-compliant exception and interrupt names, such as <code>PendSV_Handler</code>, <code>NMI_Handler</code>, etc.<br  />
 </dd>
<dd>
The <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> port specifically does <b>not</b> use the SVC exception (Supervisor Call). This makes the <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> ports compatible with various "hypervisors" (such as mbed uVisor or Nordic SoftDevice), which use the SVC exception.</dd></dl>
<ul>
<li>You need to explicitly <b>assign priorities of the all interrupts</b> used in your application, as described in <a class="el" href="arm-cm.html#arm-cm_int">Interrupts in the QP/C Ports to ARM Cortex-M</a>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>For ARMv7M or higher architectures (M3/M4/M7/M33...), the <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> initialization code (executed from the <a class="el" href="class_q_f.html" title="QF Active Object Framework (QF namespace emulated as a &quot;class&quot; in C)">QF</a> initialization) initializes all interrupt priorities to the safe value maskable with the BASEPRI register. However, this is just a safety precaution not to leave the interrupts kernel-unaware, which they are out of reset. It is highly recommended to set the priorities of all interrupts explicitly in the application-level code.</dd></dl>
<ul>
<li>It is strongly recommended that you do not assign the lowest NVIC priority (0xFF) to any interrupt in your application, because it is used by the PendSV handler. For example, with 3 bits of priority implemented in the NVIC, this leaves the following 7 priority levels for you (listed from the lowest to the highest urgency): 0xC0, 0xA0, 0x80, 0x60, 0x40, 0x20, and 0x00 (the highest priority).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The prioritization of interrupts, including the PendSV exception, is performed entirely by the NVIC. Because the PendSV has the lowest priority in the system, the NVIC tail-chains to the PendSV exception only after exiting the last nested interrupt.</dd></dl>
<ul>
<li>ISRs are written as regular C functions, but they need to call <a class="el" href="qp__port_8h.html#a9a4f06cd5bb50808046fe459a23aca9d" title="Define the ISR entry sequence.">QXK_ISR_ENTRY()</a> before using any <a class="el" href="class_q_f.html" title="QF Active Object Framework (QF namespace emulated as a &quot;class&quot; in C)">QF</a> services, and they must call <a class="el" href="qp__port_8h.html#a98abaa40c6aaacf63e565782ec4a2cfb" title="Define the ISR exit sequence.">QXK_ISR_EXIT()</a> after using any of the <a class="el" href="class_q_f.html" title="QF Active Object Framework (QF namespace emulated as a &quot;class&quot; in C)">QF</a> services.</li>
<li>ARM Cortex-M enters interrupt context without disabling interrupts. Generally, you should not disable interrupts inside your ISRs. In particular, the <a class="el" href="class_q_f.html" title="QF Active Object Framework (QF namespace emulated as a &quot;class&quot; in C)">QF</a> services (such as <a class="el" href="qp_8h.html#afd57334f2a1664a168b0702a106e0782">QF_PUBLISH()</a>, <a class="el" href="qp_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">QF_TICK_X()</a>, and <a class="el" href="qp_8h.html#ab7c56990d949c8708e3fe2b737f2e65c">QACTIVE_POST()</a>) should be called with interrupts enabled, to avoid nesting of critical sections.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If you don't wish an interrupt to be preempted by another interrupt, you can always prioritize that interrupt in the NVIC to a higher or equal level as other interrupts (use a lower numerical value of priority).</dd></dl>
<ul>
<li>In compliance with the ARM Application Procedure Call Standard (AAPCS), the <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> kernel always preserves the 8-byte alignment of the stack (both MSP and PSP).</li>
</ul>
<p><b>Using the VFP</b><br  />
 If you have the ARMv7M or higher architectures (ARMv7M or higher architectures) and your application is compiled with the VFP present, the <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> kernel will enable the VFP along with the VFP automatic state preservation and lazy stacking features. This will cause the NVIC to automatically use the VFP-exception stack frame (with additional 18 VFP registers S0-S15 plus VFP status and stack "aligner"). The <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> context switch will add to this the rest of the VFP registers (S16-S31) on context switches to and from extended threads.</p>
<dl class="section note"><dt>Note</dt><dd>With VFP enabled, any <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> thread (both a basic and an extended thread) will use 136 more bytes of its stack space, regardless if VFP is actually used by this thread. However, due to the "lazy-stacking" hardware feature, only a thread that actually uses the VFP will save and restore the VFP registers on the stack (which will cost some additional CPU cycles to perform a context switch). </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="ports.html">Ports</a></li><li class="navelem"><a class="el" href="ports_native.html">Native Ports (Built-in Kernels)</a></li><li class="navelem"><a class="el" href="arm-cm.html">ARM Cortex-M</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2024 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 7.3.4</b> &nbsp;|&nbsp; Updated on Thu Mar 21 2024
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2024 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 7.3.4</b> &nbsp;|&nbsp; Updated on Thu Mar 21 2024
</small></address>
    </li>
  </ul>
</div>
</body>
</html>
