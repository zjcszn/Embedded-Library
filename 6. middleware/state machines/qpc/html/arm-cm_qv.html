<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: Cooperative QV Kernel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="ql-preview.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="ql-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.png"/></a>
  </div>
   <div id="projectname">
    QP/C
    &nbsp;<span id="projectnumber">7.3.4</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('arm-cm_qv.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Cooperative QV Kernel</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The non-preemptive, cooperative <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> kernel executes active objects one at a time, with priority-based scheduling performed after run-to-completion (RTC) processing of each event. Due to naturally short duration of event processing in state machines, the simple <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> kernel is often adequate for many real-time systems. (NOTE: Long RTC steps can be often broken into shorter pieces by means of the "Reminder" state pattern [<a class="el" href="arm-cm.html#Reminder">Reminder</a>])</p>
<dl class="section remark"><dt>Remarks</dt><dd>In the <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> port, the only components requiring platform-specific porting are <a class="el" href="class_q_f.html" title="QF Active Object Framework (QF namespace emulated as a &quot;class&quot; in C)">QF</a> and <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> itself. The other two components: QEP and <a class="el" href="struct_q_s.html" title="Software tracing instrumentation, target-resident component (QS namespace emulated as a &quot;class&quot; in C)">QS</a> require merely recompilation and will not be discussed here. With the <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> port you're not using the <a class="el" href="struct_q_k.html" title="QK preemptive non-blocking kernel (QK namespace emulated as a &quot;class&quot; in C)">QK</a> or <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a> kernels. The <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> port to ARM Cortex-M is located in the folder <span class="img folder">/ports/arm-cm/qv/</span>.</dd></dl>
<p><b>Synopsis of the <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> Port on ARM Cortex-M</b><br  />
 The cooperative <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> kernel works essentially as the traditional foreground-background system (a.k.a. "superloop") in that all active objects are executed in the main loop and interrupts always return back to the point of preemption. To avoid race conditions between the main loop and the interrupts, <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> briefly disables interrupts.</p>
<ol type="1">
<li>The ARM Cortex-M processor executes application code (the main loop) in the Privileged Thread mode, which is exactly the mode entered out of reset.</li>
<li>The exceptions (including all interrupts) are always processed in the Privileged Handler mode.</li>
<li><a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> uses only the Main Stack Pointer. The Process Stack Pointer is not used and is not initialized.</li>
<li>ARM Cortex-M enters interrupt context without disabling interrupts (without setting the PRIMASK bit or the BASEPRI register). Generally, you should not disable interrupts inside your ISRs. In particular, the QP services <a class="el" href="qp_8h.html#afd57334f2a1664a168b0702a106e0782">QF_PUBLISH()</a>, <a class="el" href="qp_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">QF_TICK_X()</a>, and <a class="el" href="qp_8h.html#ab7c56990d949c8708e3fe2b737f2e65c">QACTIVE_POST()</a> should be called with <b>interrupts enabled</b>, to avoid nesting of critical sections.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>If you don't wish an interrupt to be preempted by another interrupt, you can always prioritize that interrupt in the NVIC to a higher level (use a lower numerical value of priority).</dd></dl>
<ol type="1">
<li>The <code><a class="el" href="qutest_8c.html#adac7eccb860d910c4e446d3143798bba">QF_init()</a></code> function calls the function <code>QV_init()</code> to set the interrupt priority of all IRQs available in the MCU to the safe value of <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a> (for ARM-v7 architecture).</li>
</ol>
<p><b>The <a class="el" href="qp__port_8h.html" title="Sample QP/C port.">qp_port.h</a> Header File</b><br  />
 The <a class="el" href="class_q_f.html" title="QF Active Object Framework (QF namespace emulated as a &quot;class&quot; in C)">QF</a> header file for the ARM Cortex-M port is located in <span class="img file_h"><code>/ports/arm-cm/qv/gnu/qp_port.h</code></span>. This file specifies the interrupt disabling policy (<a class="el" href="class_q_f.html" title="QF Active Object Framework (QF namespace emulated as a &quot;class&quot; in C)">QF</a> critical section) as well as the configuration constants for <a class="el" href="class_q_f.html" title="QF Active Object Framework (QF namespace emulated as a &quot;class&quot; in C)">QF</a> (see Chapter 8 in [PSiCC2]).</p>
<dl class="section note"><dt>Note</dt><dd>The ARM Cortex-M allows you to use the simplest "unconditional interrupt disabling" policy (see Section 7.3.2 in [PSiCC2]), because ARM Cortex-M is equipped with the standard nested vectored interrupt controller (NVIC) and generally runs ISRs with interrupts enabled (so the body of an ISR is not a critical section).</dd></dl>
<p>The following listing shows the <code><a class="el" href="qp__port_8h.html" title="Sample QP/C port.">qp_port.h</a></code> header file for ARM Cortex-M with the GNU-ARM toolchain. Other toolchains use slightly different conditional compilation macros to select the Cortex-M variants, but implement the same policies.</p>
<p><a class="anchor" id="arm-cm_qf_port_h-code"></a></p><div class="caption"><center><em>Listing: The <a class="el" href="qp__port_8h.html" title="Sample QP/C port.">qp_port.h</a> header file for ARM Cortex-M</em></center></div> <div class="fragment"><div class="line"><span class="preprocessor">     #include &lt;stdint.h&gt;</span>  <span class="comment">/* Exact-width types. WG14/N843 C99 Standard */</span></div>
<div class="line"><span class="preprocessor">     #include &lt;stdbool.h&gt;</span> <span class="comment">/* Boolean type.      WG14/N843 C99 Standard */</span></div>
<div class="line"> </div>
<div class="line">     <span class="comment">/* The maximum number of active objects in the application, see NOTE1 */</span></div>
<div class="line"> [1] #define <a class="code hl_define" href="qp__config_8h.html#a776d2a032974db4bf9bcfde01ace1389">QF_MAX_ACTIVE</a>            32</div>
<div class="line"> </div>
<div class="line">     <span class="comment">/* The maximum number of system clock tick rates */</span></div>
<div class="line"> [2] #define <a class="code hl_define" href="qp__config_8h.html#a2b5eb0c96105f58726359f4fcfae9530">QF_MAX_TICK_RATE</a>         2</div>
<div class="line"> </div>
<div class="line">     <span class="comment">/* QF interrupt disable/enable and log2()... */</span></div>
<div class="line"> [3] #<span class="keywordflow">if</span> (__ARM_ARCH == 6) <span class="comment">/* Cortex-M0/M0+/M1(v6-M, v6S-M)? */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* Cortex-M0/M0+/M1(v6-M, v6S-M) interrupt disabling policy, see NOTE2 */</span></div>
<div class="line"> [4]     #define <a class="code hl_define" href="qp__port_8h.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a>()     __asm volatile (&quot;cpsid i&quot;)</div>
<div class="line"> [5]     <span class="preprocessor">#define QF_INT_ENABLE()      __asm volatile (&quot;cpsie i&quot;</span>)</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* QF critical section (unconditional interrupt disabling) */</span></div>
<div class="line"> [6]     #define <a class="code hl_define" href="qsafe_8h.html#af8d7831ad960cc7d985fb3d70c54cac0">QF_CRIT_STAT</a></div>
<div class="line"> [7]     #define <a class="code hl_define" href="qsafe_8h.html#a825bd2cd3576ca7713b5e30a21ad263d">QF_CRIT_ENTRY</a>()      <a class="code hl_define" href="qp__port_8h.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a>()</div>
<div class="line"> [8]     <span class="preprocessor">#define QF_CRIT_EXIT()       QF_INT_ENABLE()</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* CMSIS threshold for &quot;QF-aware&quot; interrupts, see NOTE2 and NOTE5 */</span></div>
<div class="line"> [9]     #define QF_AWARE_ISR_CMSIS_PRI 0</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* hand-optimized LOG2 in assembly for Cortex-M0/M0+/M1(v6-M, v6S-M) */</span></div>
<div class="line">[10]     #define <a class="code hl_function" href="qp_8h.html#a0fb2499d124f79606d6d5881e082fdda">QF_LOG2</a>(n_) QF_qlog2((n_))</div>
<div class="line"> </div>
<div class="line">[11] #<span class="keywordflow">else</span> <span class="comment">/* Cortex-M3/M4/M7 */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* Cortex-M3/M4/M7 alternative interrupt disabling with PRIMASK */</span></div>
<div class="line">[12]     #define QF_PRIMASK_DISABLE() __asm volatile (&quot;cpsid i&quot;)</div>
<div class="line">[13]     <span class="preprocessor">#define QF_PRIMASK_ENABLE()  __asm volatile (&quot;cpsie i&quot;</span>)</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* Cortex-M3/M4/M7 interrupt disabling policy, see NOTE3 and NOTE4 */</span></div>
<div class="line">[14]     #define <a class="code hl_define" href="qp__port_8h.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a>() __asm volatile (\</div>
<div class="line">             &quot;cpsid i\n&quot; &quot;msr BASEPRI,%0\n&quot; &quot;cpsie i&quot; :: &quot;r&quot; (QF_BASEPRI) : )</div>
<div class="line">[15]     <span class="preprocessor">#define QF_INT_ENABLE()  __asm volatile (\</span></div>
<div class="line"><span class="preprocessor">             &quot;msr BASEPRI,%0&quot;</span> :: &quot;r&quot; (0) : )</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* QF critical section (unconditional interrupt disabling) */</span></div>
<div class="line">[16]     #define <a class="code hl_define" href="qsafe_8h.html#af8d7831ad960cc7d985fb3d70c54cac0">QF_CRIT_STAT</a></div>
<div class="line">[17]     #define <a class="code hl_define" href="qsafe_8h.html#a825bd2cd3576ca7713b5e30a21ad263d">QF_CRIT_ENTRY</a>()      <a class="code hl_define" href="qp__port_8h.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a>()</div>
<div class="line">[18]     <span class="preprocessor">#define QF_CRIT_EXIT()       QF_INT_ENABLE()</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* BASEPRI threshold for &quot;QF-aware&quot; interrupts, see NOTE3 */</span></div>
<div class="line">[19]     #define QF_BASEPRI           0x3F</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* CMSIS threshold for &quot;QF-aware&quot; interrupts, see NOTE5 */</span></div>
<div class="line">[20]     #define QF_AWARE_ISR_CMSIS_PRI (QF_BASEPRI &gt;&gt; (8 - __NVIC_PRIO_BITS))</div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* Cortex-M3/M4/M7 provide the CLZ instruction for fast LOG2 */</span></div>
<div class="line">[21]     #define <a class="code hl_function" href="qp_8h.html#a0fb2499d124f79606d6d5881e082fdda">QF_LOG2</a>(n_) ((uint_fast8_t)(32U - __builtin_clz(n_)))</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">     #endif</span></div>
<div class="line"> </div>
<div class="line">[22] #define <a class="code hl_define" href="qp_8h.html#adc8820f52d450bcfb7d1f830e6c8a8c2">QF_CRIT_EXIT_NOP</a>()       __asm volatile (&quot;isb&quot;)</div>
<div class="line"> </div>
<div class="line">     <span class="preprocessor">#if (__ARM_ARCH == 6) </span><span class="comment">/* Cortex-M0/M0+/M1(v6-M, v6S-M)? */</span><span class="preprocessor"></span></div>
<div class="line">         <span class="comment">/* hand-optimized quick LOG2 in assembly */</span></div>
<div class="line">[23]     uint_fast8_t QF_qlog2(uint32_t x);</div>
<div class="line"><span class="preprocessor">     #endif </span><span class="comment">/* Cortex-M0/M0+/M1(v6-M, v6S-M) */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line">     <span class="comment">// include files -------------------------------------------------------------</span></div>
<div class="line"><span class="preprocessor">     #include &quot;<a class="code" href="qequeue_8h.html">qequeue.h</a>&quot;</span>  <span class="comment">// QV kernel uses the native QP event queue</span></div>
<div class="line"><span class="preprocessor">     #include &quot;<a class="code" href="qmpool_8h.html">qmpool.h</a>&quot;</span>   <span class="comment">// QV kernel uses the native QP memory pool</span></div>
<div class="line"><span class="preprocessor">     #include &quot;<a class="code" href="qp_8h.html">qp.h</a>&quot;</span>       <span class="comment">// QP framework</span></div>
<div class="line"><span class="preprocessor">     #include &quot;<a class="code" href="qv_8h.html">qv.h</a>&quot;</span>       <span class="comment">// QV kernel</span></div>
<div class="ttc" id="aqequeue_8h_html"><div class="ttname"><a href="qequeue_8h.html">qequeue.h</a></div><div class="ttdoc">QP natvie, platform-independent, thread-safe event queue interface.</div></div>
<div class="ttc" id="aqmpool_8h_html"><div class="ttname"><a href="qmpool_8h.html">qmpool.h</a></div><div class="ttdoc">QP native, platform-independent memory pool QMPool interface.</div></div>
<div class="ttc" id="aqp_8h_html"><div class="ttname"><a href="qp_8h.html">qp.h</a></div><div class="ttdoc">QP/C platform-independent public interface.</div></div>
<div class="ttc" id="aqp_8h_html_a0fb2499d124f79606d6d5881e082fdda"><div class="ttname"><a href="qp_8h.html#a0fb2499d124f79606d6d5881e082fdda">QF_LOG2</a></div><div class="ttdeci">uint_fast8_t QF_LOG2(QPSetBits const bitmask)</div><div class="ttdef"><b>Definition</b> <a href="qf__act_8c_source.html#l00090">qf_act.c:90</a></div></div>
<div class="ttc" id="aqp_8h_html_adc8820f52d450bcfb7d1f830e6c8a8c2"><div class="ttname"><a href="qp_8h.html#adc8820f52d450bcfb7d1f830e6c8a8c2">QF_CRIT_EXIT_NOP</a></div><div class="ttdeci">#define QF_CRIT_EXIT_NOP()</div><div class="ttdef"><b>Definition</b> <a href="qp_8h_source.html#l01265">qp.h:1265</a></div></div>
<div class="ttc" id="aqp__config_8h_html_a2b5eb0c96105f58726359f4fcfae9530"><div class="ttname"><a href="qp__config_8h.html#a2b5eb0c96105f58726359f4fcfae9530">QF_MAX_TICK_RATE</a></div><div class="ttdeci">#define QF_MAX_TICK_RATE</div><div class="ttdef"><b>Definition</b> <a href="qp__config_8h_source.html#l00130">qp_config.h:130</a></div></div>
<div class="ttc" id="aqp__config_8h_html_a776d2a032974db4bf9bcfde01ace1389"><div class="ttname"><a href="qp__config_8h.html#a776d2a032974db4bf9bcfde01ace1389">QF_MAX_ACTIVE</a></div><div class="ttdeci">#define QF_MAX_ACTIVE</div><div class="ttdef"><b>Definition</b> <a href="qp__config_8h_source.html#l00112">qp_config.h:112</a></div></div>
<div class="ttc" id="aqp__port_8h_html_a88df5203e3a9716327b58923f5aaac80"><div class="ttname"><a href="qp__port_8h.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a></div><div class="ttdeci">#define QF_INT_DISABLE()</div><div class="ttdoc">Disable interrupts.</div><div class="ttdef"><b>Definition</b> <a href="qp__port_8h_source.html#l00037">qp_port.h:37</a></div></div>
<div class="ttc" id="aqsafe_8h_html_a825bd2cd3576ca7713b5e30a21ad263d"><div class="ttname"><a href="qsafe_8h.html#a825bd2cd3576ca7713b5e30a21ad263d">QF_CRIT_ENTRY</a></div><div class="ttdeci">#define QF_CRIT_ENTRY()</div><div class="ttdef"><b>Definition</b> <a href="qsafe_8h_source.html#l00058">qsafe.h:58</a></div></div>
<div class="ttc" id="aqsafe_8h_html_af8d7831ad960cc7d985fb3d70c54cac0"><div class="ttname"><a href="qsafe_8h.html#af8d7831ad960cc7d985fb3d70c54cac0">QF_CRIT_STAT</a></div><div class="ttdeci">#define QF_CRIT_STAT</div><div class="ttdef"><b>Definition</b> <a href="qsafe_8h_source.html#l00054">qsafe.h:54</a></div></div>
<div class="ttc" id="aqv_8h_html"><div class="ttname"><a href="qv_8h.html">qv.h</a></div><div class="ttdoc">QV/C (non-preemptive kernel) platform-independent public interface.</div></div>
</div><!-- fragment --><p><code>[1]</code> The <a class="el" href="qp__config_8h.html#a776d2a032974db4bf9bcfde01ace1389">QF_MAX_ACTIVE</a> specifies the maximum number of active object priorities in the application. You always need to provide this constant. Here, <a class="el" href="qp__config_8h.html#a776d2a032974db4bf9bcfde01ace1389">QF_MAX_ACTIVE</a> is set to 32, but it can be increased up to the maximum limit of 63 active object priorities in the system.</p>
<dl class="section note"><dt>Note</dt><dd>The <code><a class="el" href="qp__port_8h.html" title="Sample QP/C port.">qp_port.h</a></code> header file does not change the default settings for all the rest of various object sizes inside <a class="el" href="class_q_f.html" title="QF Active Object Framework (QF namespace emulated as a &quot;class&quot; in C)">QF</a>. Please refer to Chapter 8 of [PSiCC2] for discussion of all configurable <a class="el" href="class_q_f.html" title="QF Active Object Framework (QF namespace emulated as a &quot;class&quot; in C)">QF</a> parameters.</dd></dl>
<p><code>[2]</code> The macro <code>QF_MAX_TICK_RATE</code> specifies the maximum number of clock tick rates for QP/C time events. If you do not need to specify this limit, in which case the default of a single clock rate will be chosen.</p>
<p><code>[3]</code> As described in the previous <a class="el" href="arm-cm.html#arm-cm_int">Section</a>, the interrupt disabling policy for the ARMv6-M architecture (Cortex-M0/M0+) is different than the policy for the ARMv7-M. In GNU-ARM, the macro <code>__ARM_ARCH</code> is defined as 6 for the ARMv6-M architecture (Cortex-M0/M0+), and 7 for ARMv7-M (Cortex-M3/M4/M4F).</p>
<dl class="section note"><dt>Note</dt><dd>The <code>__ARM_ARCH</code> macro is specific to the GNU-ARM compiler. Other compilers for ARM Cortex-M provide different macros to detect the CPU type.</dd></dl>
<p><code>[4-5]</code> For the ARMv6-M architecture, the interrupt disabling policy uses the PRIMASK register to disable interrupts globally. The <code><a class="el" href="qp__port_8h.html#a88df5203e3a9716327b58923f5aaac80" title="Disable interrupts.">QF_INT_DISABLE()</a></code> macro resolves in this case to the inline assembly instruction "CPSD i", which sets the PRIMASK. The <code><a class="el" href="qp__port_8h.html#ad2d11956704ad838c9c954368d3d37d5" title="Enable interrupts.">QF_INT_ENABLE()</a></code> macro resolves to the inline assembly instruction "CPSE i", which clears the PRIMASK.</p>
<p><code>[6]</code> The <a class="el" href="qsafe_8h.html#af8d7831ad960cc7d985fb3d70c54cac0">QF_CRIT_STAT</a> is empty, meaning that the critical section uses the simple policy of "unconditional interrupt disabling".</p>
<dl class="section note"><dt>Note</dt><dd>The "unconditional interrupt disabling" policy precludes nesting of critical sections, but this is not needed for ARM Cortex-M, because this CPU never disables interrupts, even when handling exceptions/interrupts.</dd></dl>
<p><code>[7]</code> The QF_CRIT_ENRY() enters a critical section. Interrupts are disabled by setting the PRIMASK register.</p>
<p><code>[8]</code> The <a class="el" href="qsafe_8h.html#af244388ce617361789cb131c70bc0043">QF_CRIT_EXIT()</a> macro leaves the critical section. Interrupts are unconditionally re-enabled by clearing the PRIMASK register.</p>
<p><code>[9]</code> For the ARMv6-M architecture, the <code>QF_AWARE_ISR_CMSIS_PRI</code> priority level is defined as zero, meaning that all interrupts are "kernel-aware", because all interrupt priorities are disabled by the kernel.</p>
<p><code>[10]</code> The <code><a class="el" href="qp_8h.html#a0fb2499d124f79606d6d5881e082fdda">QF_LOG2()</a></code> macro is defined as a call to the function <code>QF_qlog2()</code> ("quick log-base-2 logarithm"). This function is coded in hand-optimized assembly, which always takes only 14 CPU cycles to execute (see also label [23]).</p>
<dl class="section note"><dt>Note</dt><dd>ARM Cortex-M0/M0+ does NOT implement the <code>CLZ</code> instruction. Therefore the log-base-2 calculation cannot be accelerated in hardware, as it is for ARM Cortex-M3 and higher.</dd></dl>
<p><code>[11]</code> For the ARMv7-M (Cortex-M3/M4/M4F) architecture...</p>
<p><code>[12]</code> The <code>QF_PRIMASK_DISABLE()</code> macro resolves to the inline assembly instruction <code>CPSD i</code>, which sets the PRIMASK.</p>
<p><code>[13]</code> The <code>QF_PRIMASK_ENABLE()</code> macro resolves to the inline assembly instruction <code>CPSE i</code>, which clears the PRIMASK.</p>
<p><code>[14]</code> Interrupts are disabled by setting the BASEPRI register to the value defined in the <code>QF_BASEPRI</code> macro (see label <code>[19]</code>). This setting of the BASEPRI instruction <code>msr BASEPRI,...</code> is surrounded by setting and clearing the PRIMASK register, as a workaround a hardware problem in ARMv7M or higher architectures core r0p1:</p>
<dl class="section note"><dt>Note</dt><dd>The selective disabling of "QF-aware" interrupts with the BASEPRI register has a problem on ARMv7M or higher architectures core r0p1 (see [<a class="el" href="arm-cm.html#ARM-EPM-064408">ARM-EPM-064408</a>], Erratum 837070). The workaround recommended by ARM is to surround <code>MSR BASEPRI,...</code> with the <code>CPSID i</code>/<code>CPSIE i</code> pair, which is implemented in the <a class="el" href="qp__port_8h.html#a88df5203e3a9716327b58923f5aaac80" title="Disable interrupts.">QF_INT_DISABLE()</a> macro. This workaround works also for Cortex-M3/M4 cores.</dd></dl>
<p><code>[15]</code> The <code><a class="el" href="qp__port_8h.html#ad2d11956704ad838c9c954368d3d37d5" title="Enable interrupts.">QF_INT_ENABLE()</a></code> macro sets the BASEPRI register to zero, which disables BASEPRI interrupt masking.</p>
<dl class="section note"><dt>Note</dt><dd>This method can never disable interrupt of priority 0 (highest).</dd></dl>
<p><code>[16]</code> The <a class="el" href="qsafe_8h.html#af8d7831ad960cc7d985fb3d70c54cac0">QF_CRIT_STAT</a> is empty, meaning that the critical section uses the simple policy of "unconditional interrupt disabling".</p>
<dl class="section note"><dt>Note</dt><dd>The "unconditional interrupt disabling" policy precludes nesting of critical sections, but this is not needed for ARM Cortex-M, because this CPU never disables interrupts, even when handling exceptions/interrupts.</dd></dl>
<p><code>[17]</code> The <a class="el" href="qsafe_8h.html#a825bd2cd3576ca7713b5e30a21ad263d">QF_CRIT_ENTRY()</a> enters a critical section. Interrupts are disabled with the macro <code><a class="el" href="qp__port_8h.html#a88df5203e3a9716327b58923f5aaac80" title="Disable interrupts.">QF_INT_DISABLE()</a></code> defined at label [12].</p>
<p><code>[18]</code> The <a class="el" href="qsafe_8h.html#af244388ce617361789cb131c70bc0043">QF_CRIT_EXIT()</a> macro leaves the critical section. Interrupts are unconditionally re-enabled with the macro <code><a class="el" href="qp__port_8h.html#ad2d11956704ad838c9c954368d3d37d5" title="Enable interrupts.">QF_INT_ENABLE()</a></code> defined at label [13].</p>
<p><a class="anchor" id="QF_BASEPRI"></a><code>[19]</code> The <code>QF_BASEPRI</code> value is defined such that it is the lowest priority for the minimum number of 3 priority-bits that the ARMv7M or higher architectures architecture must provide. This partitions the interrupts as "kernel-unaware" and "kernel-aware" interrupts, as shown in section arm-cm_int-assign.</p>
<p><code>[20]</code> For the ARMv7-M architecture, the <code>QF_AWARE_ISR_CMSIS_PRI</code> priority level suitable for the CMSIS function <code>NVIC_SetPriority()</code> is determined by the <code>QF_BASEPRI</code> value.</p>
<p><code>[21]</code> The macro <code><a class="el" href="qp_8h.html#a0fb2499d124f79606d6d5881e082fdda">QF_LOG2()</a></code> is defined to take advantage of the CLZ instruction (Count Leading Zeroes), which is available in the ARMv7-M architecture.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>__builtin_cls()</code> intrinsic function is specific to the GNU-ARM compiler. Other compilers for ARM Cortex-M use different function names for this intrinsic function.</dd></dl>
<p><code>[22]</code> The macro <code><a class="el" href="qp_8h.html#adc8820f52d450bcfb7d1f830e6c8a8c2">QF_CRIT_EXIT_NOP()</a></code> provides the protection against merging two critical sections occurring back-to-back in the QP/C code.</p>
<p><code>[23]</code> For ARMv6 architecture, the prototype of the quick, hand-optimized log-base-2 function is provided (see also label [10]).</p>
<p><b>The qv_port.h Header File</b><br  />
 The <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> header file for the ARM Cortex-M port is located in <span class="img file_h">/ports/arm-cm/qv/gnu/qv_port.h</span>. This file provides the macro <a class="el" href="qp__port_8h.html#a63d09440889262e482687c417690fea4" title="! def QF_MEM_ISOLATE">QV_CPU_SLEEP()</a>, which specifies how to enter the CPU sleep mode safely in the cooperative <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> kernel (see also Section 4.7) and [Samek 07]).</p>
<dl class="section note"><dt>Note</dt><dd>To avoid race conditions between interrupts waking up active objects and going to sleep, the cooperative <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> kernel calls the <a class="el" href="qp__port_8h.html#a63d09440889262e482687c417690fea4" title="! def QF_MEM_ISOLATE">QV_CPU_SLEEP()</a> callback with interrupts disabled.</dd></dl>
<p><code>[1]</code> For the ARMv6-M architecture, the macro <code><a class="el" href="qp__port_8h.html#a63d09440889262e482687c417690fea4" title="! def QF_MEM_ISOLATE">QV_CPU_SLEEP()</a></code> stops the CPU with the WFI instruction (Wait For Interrupt). After the CPU is woken up by an interrupt, interrupts are re-enabled with the PRIMASK.</p>
<p><code>[2]</code> For the ARMv7-M architecture, the macro <code><a class="el" href="qp__port_8h.html#a63d09440889262e482687c417690fea4" title="! def QF_MEM_ISOLATE">QV_CPU_SLEEP()</a></code> first disables interrupts by setting the PRIMASK, then clears the BASEPRI to enable all "kernel-aware" interrupts and only then stops the CPU with the WFI instruction (Wait For Interrupt). After the CPU is woken up by an interrupt, interrupts are re-enabled with the PRIMASK. This sequence is necessary, because the ARMv7M or higher architectures cannot be woken up by any interrupt blocked by the BASEPRI register.</p>
<p><code>[3]</code> The macro <code>QV_INIT()</code> is defined as a call to the <code>QV_init()</code> function, which means that this function will be called from <code><a class="el" href="qutest_8c.html#adac7eccb860d910c4e446d3143798bba">QF_init()</a></code>. The <code>QV_init()</code> function initializes all available IRQ priorities in the MCU to the safe value of <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a>.</p>
<p><b>The qv_port.c Implementation File</b><br  />
 The <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> implementation file for the ARM Cortex-M port is located in <span class="img file_c">/ports/arm-cm/qv/gnu/qf_port.c</span>. This file defines the function <code>QV_init()</code>, which for the ARMv7-M architecture sets the interrupt priorities of all IRQs to the safe value <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a>.</p>
<p><a class="anchor" id="arm-cm_qv_port_c-code"></a></p><div class="caption"><center><em>Listing: The qv_port.c header file for ARM Cortex-M</em></center></div> <div class="fragment"><div class="line"><span class="preprocessor">    #include &quot;<a class="code" href="qp__port_8h.html">qp_port.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line">[1] #<span class="keywordflow">if</span> (__ARM_ARCH != 6) <span class="comment">/* NOT Cortex-M0/M0+/M1 ? */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    #define SCnSCB_ICTR  ((uint32_t volatile *)0xE000E004)</span></div>
<div class="line"><span class="preprocessor">    #define SCB_SYSPRI   ((uint32_t volatile *)0xE000ED14)</span></div>
<div class="line"><span class="preprocessor">    #define NVIC_IP      ((uint32_t volatile *)0xE000E400)</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> QV_init(<span class="keywordtype">void</span>) {</div>
<div class="line">        uint32_t n;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* set exception priorities to QF_BASEPRI...</span></div>
<div class="line"><span class="comment">          SCB_SYSPRI1: Usage-fault, Bus-fault, Memory-fault</span></div>
<div class="line"><span class="comment">         /</span></div>
<div class="line"><span class="comment">[2]     SCB_SYSPRI[1] |= (QF_BASEPRI &lt;&lt; 16) | (QF_BASEPRI &lt;&lt; 8) | QF_BASEPRI;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">        /* SCB_SYSPRI2: SVCall */</span></div>
<div class="line">[3]     SCB_SYSPRI[2] |= (QF_BASEPRI &lt;&lt; 24);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* SCB_SYSPRI3:  SysTick, PendSV, Debug */</span></div>
<div class="line">[4]     SCB_SYSPRI[3] |= (QF_BASEPRI &lt;&lt; 24) | (QF_BASEPRI &lt;&lt; 16) | QF_BASEPRI;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* set all implemented IRQ priories to QF_BASEPRI... */</span></div>
<div class="line">[5]     n = 8 + (*SCnSCB_ICTR &lt;&lt; 3); <span class="comment">/* # interrupt priority registers */</span></div>
<div class="line">        <span class="keywordflow">do</span> {</div>
<div class="line">            --n;</div>
<div class="line">[6]         NVIC_IP[n] = (QF_BASEPRI &lt;&lt; 24) | (QF_BASEPRI &lt;&lt; 16)</div>
<div class="line">                         | (QF_BASEPRI &lt;&lt; 8) | QF_BASEPRI;</div>
<div class="line">        } <span class="keywordflow">while</span> (n != 0);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    #endif </span><span class="comment">/* NOT Cortex-M0/M0+/M1 */</span><span class="preprocessor"></span></div>
<div class="ttc" id="aqp__port_8h_html"><div class="ttname"><a href="qp__port_8h.html">qp_port.h</a></div><div class="ttdoc">Sample QP/C port.</div></div>
</div><!-- fragment --><p><code>[1]</code> For the ARMv7-M architecture (Cortex-M3/M4/M7)...</p>
<p><code>[2]</code> The exception priorities for User-Fault, Bus-Fault, and Mem-Fault are set to the value <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a>.</p>
<p><code>[3]</code> The exception priority for SVCCall is set to the value <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a>.</p>
<p><code>[4]</code> The exception priority for SysTick, PendSV, and Debug is set to the value <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a>.</p>
<p><code>[5]</code> The number of implemented IRQs is read from the <code>SCnSCB_ICTR</code> register</p>
<p><code>[6]</code> The interrupt priority of all implemented IRQs is set to the safe value <a class="el" href="arm-cm_qv.html#QF_BASEPRI">QF_BASEPRI</a> in a loop.</p>
<p><b>Writing ISRs for <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a></b><br  />
 The ARM Cortex-M CPU is designed to use regular C functions as exception and interrupt service routines (ISRs).</p>
<dl class="section note"><dt>Note</dt><dd>The ARM EABI (Embedded Application Binary Interface) requires the stack be 8-byte aligned, whereas some compilers guarantee only 4-byte alignment. For that reason, some compilers (e.g., GNU-ARM) provide a way to designate ISR functions as interrupts. For example, the GNU-ARM compiler provides the <b>attribute</b>((<b>interrupt</b>)) designation that will guarantee the 8-byte stack alignment.</dd></dl>
<p>Typically, ISRs are application-specific (with the main purpose to produce events for active objects). Therefore, ISRs are not part of the generic QP/C port, but rather part of the BSP (Board Support Package).</p>
<p>The following listing shows an example of the SysTick_Handler() ISR (from the DPP example application). This ISR calls the <a class="el" href="qp_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">QF_TICK_X()</a> macro to perform <a class="el" href="class_q_f.html" title="QF Active Object Framework (QF namespace emulated as a &quot;class&quot; in C)">QF</a> time-event management.</p>
<p><a class="anchor" id="arm-cm_qv-isr-code"></a></p><div class="caption"><center><em>Listing: An ISR header for <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a></em></center></div> <div class="fragment"><div class="line"><span class="keywordtype">void</span> SysTick_Handler(<span class="keywordtype">void</span>) __attribute__((__interrupt__));</div>
<div class="line"><span class="keywordtype">void</span> SysTick_Handler(<span class="keywordtype">void</span>) {</div>
<div class="line">     ~ ~ ~</div>
<div class="line">     <span class="comment">// process time events at rate 0</span></div>
<div class="line">     <a class="code hl_define" href="qp_8h.html#ad432c2e25e5d6aa8e818159f33c16542">QTIMEEVT_TICK_X</a>(0U, &amp;l_SysTick_Handler);</div>
<div class="line">}</div>
<div class="ttc" id="aqp_8h_html_ad432c2e25e5d6aa8e818159f33c16542"><div class="ttname"><a href="qp_8h.html#ad432c2e25e5d6aa8e818159f33c16542">QTIMEEVT_TICK_X</a></div><div class="ttdeci">#define QTIMEEVT_TICK_X(tickRate_, sender_)</div><div class="ttdef"><b>Definition</b> <a href="qp_8h_source.html#l01242">qp.h:1242</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The QP/C port to ARM Cortex-M complies with the CMSIS standard, which dictates the names of all exception handlers and IRQ handlers.</dd></dl>
<p><b>Using the FPU in the <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> Port</b><br  />
 If you use ARMv7M or higher CPU and your application uses the hardware FPU, it should be enabled because it is turned off out of reset. The CMSIS-compliant way of turning the FPU on looks as follows:</p>
<pre class="fragment">    SCB-&gt;CPACR |= (0xFU &lt;&lt; 20);
</pre><dl class="section note"><dt>Note</dt><dd>The FPU must be enabled before executing any floating point instruction. An attempt to execute a floating point instruction will fault if the FPU is not enabled.</dd>
<dd>
If the FPU is configured in the project, the <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> kernel initializes the FPU to use the automatic state preservation and the lazy stacking feature as follows: <pre class="fragment">    FPU-&gt;FPCCR |= (1U &lt;&lt; FPU_FPCCR_ASPEN_Pos) | (1U &lt;&lt; FPU_FPCCR_LSPEN_Pos);
</pre></dd></dl>
<p><b>FPU NOT used in the ISRs</b><br  />
 If you use the FPU only at the thread-level (inside active objects) and none of your ISRs use the FPU, you can setup the FPU not to use the automatic state preservation and not to use the lazy stacking feature as follows:</p>
<pre class="fragment">    FPU-&gt;FPCCR &amp;= ~((1U &lt;&lt; FPU_FPCCR_ASPEN_Pos) | (1U &lt;&lt; FPU_FPCCR_LSPEN_Pos));
</pre><p>With this setting, the processor uses only the standard 8-register interrupt stack frame with R0-R3,R12,LR,PC,xPSR. This scheme is the fastest and incurs no additional CPU cycles to save and restore the FPU registers.</p>
<dl class="section attention"><dt>Attention</dt><dd>This FPU setting will lead to FPU errors, if any of the ISRs indeed starts to use the FPU</dd></dl>
<p><b><a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> Idle Processing Customization in QV_onIdle()</b><br  />
 When no events are available, the non-preemptive <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> kernel invokes the platform-specific callback function QV_onIdle(), which you can use to save CPU power, or perform any other "idle" processing (such as Quantum Spy software trace output).</p>
<dl class="section note"><dt>Note</dt><dd>The idle callback QV_onIdle() must be invoked with interrupts disabled, because the idle condition can be changed by any interrupt that posts events to event queues. QV_onIdle() must internally enable interrupts, ideally atomically with putting the CPU to the power-saving mode (see also [Samek 07] and Chapter 7 in [PSiCC2]).</dd></dl>
<p>Because QV_onIdle() must enable interrupts internally, the signature of the function depends on the interrupt locking policy. In case of the simple "unconditional interrupt locking and unlocking" policy, which is used in this ARM Cortex-M port, the QV_onIdle() takes no parameters. Listing 6 shows an example implementation of QV_onIdle() for the TM4C MCU. Other ARM Cortex-M embedded microcontrollers (e.g., NXP's LPC1114/1343) handle the power-saving mode very similarly.</p>
<p><a class="anchor" id="arm-cm_qv_onidle-code"></a></p><div class="caption"><center><em>Listing: QV_onIdle() for ARM Cortex-M</em></center></div> <div class="fragment"><div class="line">[1] <span class="keywordtype">void</span> QV_onIdle(<span class="keywordtype">void</span>) { <span class="comment">/* entered with interrupts DISABLED, see NOTE01 */</span></div>
<div class="line">        ~ ~ ~</div>
<div class="line">[2] #<span class="keywordflow">if</span> defined NDEBUG</div>
<div class="line">        <span class="comment">/* Put the CPU and peripherals to the low-power mode */</span></div>
<div class="line">[3]     <a class="code hl_define" href="qp__port_8h.html#a63d09440889262e482687c417690fea4">QV_CPU_SLEEP</a>(); <span class="comment">/* atomically go to sleep and enable interrupts */</span></div>
<div class="line"><span class="preprocessor">    #else</span></div>
<div class="line">[4]     <a class="code hl_define" href="qp__port_8h.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a>(); <span class="comment">/* just enable interrupts */</span></div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line">    }</div>
<div class="ttc" id="aqp__port_8h_html_a63d09440889262e482687c417690fea4"><div class="ttname"><a href="qp__port_8h.html#a63d09440889262e482687c417690fea4">QV_CPU_SLEEP</a></div><div class="ttdeci">#define QV_CPU_SLEEP()</div><div class="ttdoc">! def QF_MEM_ISOLATE</div><div class="ttdef"><b>Definition</b> <a href="qp__port_8h_source.html#l00094">qp_port.h:94</a></div></div>
<div class="ttc" id="aqp__port_8h_html_ad2d11956704ad838c9c954368d3d37d5"><div class="ttname"><a href="qp__port_8h.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a></div><div class="ttdeci">#define QF_INT_ENABLE()</div><div class="ttdoc">Enable interrupts.</div><div class="ttdef"><b>Definition</b> <a href="qp__port_8h_source.html#l00040">qp_port.h:40</a></div></div>
</div><!-- fragment --><p><code>[1]</code> The cooperative <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> kernel calls the QV_onIdle() callback with interrupts disabled, to avoid race condition with interrupts that can post events to active objects and thus invalidate the idle condition.</p>
<p><code>[2]</code> The sleep mode is used only in the non-debug configuration, because sleep mode stops CPU clock, which can interfere with debugging.</p>
<p><code>[3]</code> The macro <a class="el" href="qp__port_8h.html#a63d09440889262e482687c417690fea4" title="! def QF_MEM_ISOLATE">QV_CPU_SLEEP()</a> is used to put the CPU to the low-power sleep mode safely. The macro <a class="el" href="qp__port_8h.html#a63d09440889262e482687c417690fea4" title="! def QF_MEM_ISOLATE">QV_CPU_SLEEP()</a> is defined in the qv_port.h header file for the <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a> kernel and depends on the interrupt disabling policy used.</p>
<p><code>[4]</code> When a sleep mode is not used, the QV_onIdle() callback simply re-enables interrupts.</p>
<p><span class="next_button"><a class="el" href="arm-cm_qk.html">Preemptive Non-Blocking QK Kernel</a></span>  </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="ports.html">Ports</a></li><li class="navelem"><a class="el" href="ports_native.html">Native Ports (Built-in Kernels)</a></li><li class="navelem"><a class="el" href="arm-cm.html">ARM Cortex-M</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2024 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 7.3.4</b> &nbsp;|&nbsp; Updated on Thu Mar 21 2024
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2024 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 7.3.4</b> &nbsp;|&nbsp; Updated on Thu Mar 21 2024
</small></address>
    </li>
  </ul>
</div>
</body>
</html>
