<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: Event Delivery Mechanisms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="ql-preview.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="ql-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.png"/></a>
  </div>
   <div id="projectname">
    QP/C
    &nbsp;<span id="projectnumber">7.3.4</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('srs_edm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Event Delivery Mechanisms</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><span class="prev_button"><a class="el" href="srs_ao.html">Active Objects</a></span><span class="next_button"><a class="el" href="srs_emm.html">Event Memory Management</a></span> </p>
<h1><a class="anchor" id="srs_edm-intro"></a>
Concepts &amp; Definitions</h1>
<p>One of the main responsibilities of the QP Framework is to reliably and safely deliver <a class="el" href="srs_evt.html">QP events</a> from various producers to Active Objects. The event delivery is <a class="el" href="srs_ao.html#srs_ao-asynch">asynchronous</a>, meaning that the producers only post events to Active Objects, but don't wait in-line for the processing of the events. Any part of the system can produce events, not necessarily only the Active Objects. For example, ISRs, device drivers, or legacy code running outside the framework can produce events. On the other hand, only Active Objects can consume QP events, because only Active Objects have <a class="el" href="srs_ao.html#srs_ao-queue">event queues</a>.</p>
<p>Generally, there are two types of event delivery mechanism (see <a class="el" href="srs_edm.html#srs_fig-41">Figure SRS-41</a>):</p>
<ol type="1">
<li><a class="el" href="srs_edm.html#src_edm-post">Direct event posting</a>, when the producer of an event directly posts the event to the event queue of the consumer Active Object.</li>
<li><a class="el" href="srs_edm.html#src_edm-ps">Publish-subscribe</a>, where a producer "publishes" an event to the framework, and the framework then delivers the event to all Active Objects that had "subscribed" to the event.</li>
</ol>
<p><a class="anchor" id="srs_fig-41"></a></p><div class="image">
<object type="image/svg+xml" data="edm.svg" width="1500px" style="pointer-events: none;"></object>
</div>
  <div class="caption"><center><em>Figure SRS-41: Event delivery mechanisms in the QP Framework</em></center></div><h2><a class="anchor" id="src_edm-post"></a>
Direct Event Posting</h2>
<p>Direct event posting is the simplest mechanism that allows producers to post events directly to the event queue of the recipient Active Object. <a class="el" href="srs_edm.html#srs_fig-41">Figure SRS-41</a> illustrates this form of communication as arrows directly connecting event producers and the consumer Active Objects.</p>
<p>Direct event posting is a "push-style" communication mechanism, in which recipients receive unsolicited events whether they "want" them or not. Direct event posting is ideal in situations where a group of Active Objects, or an Active Object and an ISR, form a subsystem providing a particular service, such as a communication stack, GPS capability, digital camera subsystem in a mobile phone, or the like. This style of event passing requires that the event producers "knows" the recipients and their interests in various events. The "knowledge" that a sender needs is, at a minimum, the handle (e.g., a pointer) to the recipient Active Object.</p>
<p>Direct event posting mechanism might increase the coupling among the components, especially when the recipients of the events are hard-coded inside the event producers. However, one way of reducing the coupling is to allow the recipients to "register" with the producers at runtime, so that the producer does not need to hard-code the recipient(s).</p>
<dl class="section remark"><dt>Remarks</dt><dd>QP Framework also provides "raw" thread-safe event queues without Active Objects behind them. Such "raw" thread-safe queues can deliver events as well, but they cannot block (even when QP runs on top of a blocking RTOS kernel) and are intended to deliver events to ISRs, that is, provide a communication mechanism from the Active Object level to the ISR level.</dd></dl>
<h2><a class="anchor" id="src_edm-ps"></a>
Publish-Subscribe</h2>
<p>Publish-subscribe event delivery is shown in <a class="el" href="srs_edm.html#srs_fig-41">Figure SRS-41</a> as a "software bus" into which Active Objects "plug in" through the specified interface. Active Objects interested in certain events <b>subscribe</b> to one or more <a class="el" href="srs_evt.html#srs_evt-sig">event signals</a> by the QP framework. Publish-subscribe is a "pull-style" communication mechanism in which recipients receive only solicited (subscribed) events. The properties of the publish-subscribe model are:</p>
<ul>
<li>Producers and consumers of events don't need to know each other (loose coupling).</li>
<li>The events exchanged via this mechanism must be publicly known and must have the same semantics to all parties.</li>
<li>Publish-subscribe implies <b>event multicasting</b> in case a given <a class="el" href="srs_evt.html#srs_evt-sig">event signal</a> is subscribed by multiple Active Objects.</li>
<li>A "mediator" (QP Framework) is required to accept published events and to deliver them to all interested subscribers.</li>
<li>Many-to-many interactions (object-to-object) are replaced with one-to-many (object-to-mediator) interactions.</li>
</ul>
<p>Event producers publish events by making publication requests to QP framework. Such requests can originate asynchronously from many sources, not necessarily just from Active Objects. For example, events can be published from interrupts (ISRs), device drivers, or the "naked" threads (in case QP runs on top of a conventional RTOS/OS). QP framework manages all these interactions by supplying the following services:</p>
<ul>
<li>Provide a way for Active Objects to subscribe and unsubscribe to particular <a class="el" href="srs_evt.html#srs_evt-sig">event signal</a>.</li>
<li>Provide a generally accessible interface for publishing events.</li>
<li>Provide a thread-safe event delivery policy, including <b>multicasting events</b> when a given event signal is subscribed by multiple Active Objects.</li>
</ul>
<h2><a class="anchor" id="src_edm-guarantee"></a>
Event Delivery Guarantee</h2>
<p>Traditional sequential systems communicate predominately using synchronous function calls. When module A wants to communicate with module B, module A calls a function in B. The communication is implicitly assumed to be <b>reliable</b>; the programmer takes for granted that the function call mechanism will work, that the parameters will be passed to the callee and that the return value will be delivered to the caller. The programmer does not conceive of any recovery strategy to handle a failure in the function call mechanism. (In fact, any such strategies would complicate the development so much that it would become impractical, while still unreliable.) However, any function call <em>can</em> fail due to insufficient stack space. Consequently, the reliability of synchronous communication is, in fact, predicated on the implicit assumption of adequate stack resources.</p>
<p>Event-driven systems communicate predominately by asynchronous event exchange. When producer A wants to communicate with Active Object B, producer A allocates an event and posts or publishes it to the event queue of Active Object B. As in the case of synchronous communication, the programmer should be able to take for granted that the event delivery mechanism will work. The programmer should not need to devise a recovery strategy to handle a failure in the basic event delivery mechanism. (In fact, such strategies would complicate the development so much that it would become impractical, while still unreliable.) However, asynchronous communication can fail due to insufficient queue capacity (or event-pool capacity; see the <a class="el" href="srs_emm.html">next section</a>). Consequently, the reliability of asynchronous communication is, in fact, predicated on the assumption of adequate event queue capacity (and event pool size).</p>
<p>An event-driven framework (like QP) shall detect event queue overruns (and event pool depletion), just like a traditional RTOS detects stack overflows. It is up to the application developer to adequately size all Active Object event queues (and event pools) in the same way, as it is the developer's responsibility to sufficiently size all execution stacks for all threads in a traditional RTOS. Given the adequately sized queues (and event pools), an event-driven framework (like QP) can and should guarantee event delivery. Such a guarantee is essential because only <em>reliable</em> event delivery can be used to build <em>reliable</em> event-driven systems.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This discussion is limited to non-distributed systems executing in a single address space. Distributed systems connected with unreliable communication media pose quite different challenges. In this case, neither synchronous communications such as remote procedure call (RPC) nor asynchronous communications via event passing can make strong guarantees.</dd></dl>
<h1><a class="anchor" id="srs_edm-req"></a>
Requirements</h1>
<p><a id="a52_REQ-QP-04_00" name="a52_REQ-QP-04_00"></a> </p>
<h2><a class="anchor" id="REQ-QP-04_00"></a>
REQ-QP-04_00</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-04_00 </th></tr>
<tr style="text-align:left">
<th>QP Framework shall provide direct event posting to Active Object instances based on the FIFO policy </th></tr>
<tr>
<td><b>Description</b><br  />
 The direct event posting mechanism shall post events to the <a class="el" href="srs_ao.html#srs_ao-queue">event queue</a> of the recipient Active Object utilizing the FIFO (First-In-First-Out) policy. Direct event posting with the default FIFO policy shall be available to all possible event producers, such as Active Objects, but also interrupts (ISRs), "device drivers", and "naked" threads of an RTOS (if an RTOS is used to run QP). The default FIFO event posting shall be also available for self-posting of events (when Active Object instance posts an event to its own event queue.) </td></tr>
<tr>
<td><b>Dependencies</b><br  />
 <a class="el" href="srs_ao.html#REQ-QP-03_20">REQ-QP-03_20</a>, <a class="el" href="srs_ao.html#REQ-QP-03_21">REQ-QP-03_21</a> </td></tr>
</table>
<p><a id="a53_REQ-QP-04_01" name="a53_REQ-QP-04_01"></a> </p>
<h2><a class="anchor" id="REQ-QP-04_01"></a>
REQ-QP-04_01</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-04_01 </th></tr>
<tr style="text-align:left">
<th>QP Framework shall provide direct event <u>self</u>-posting to Active Object instances based on the LIFO policy </th></tr>
<tr>
<td><b>Description</b><br  />
 Self-posting means that a given Active Object instance posts event to its own event queue. Such self-posting mechanism shall use the same <a class="el" href="srs_ao.html#srs_ao-queue">event queue</a> as the default FIFO policy, but shall utilize the LIFO (Last-In-First-Out) policy. The LIFO event self-posting shall be available in addition to self-posting with the default FIFO policy. </td></tr>
<tr>
<td><b>Use case</b><br  />
 Self-posting of events with the LIFO policy can be useful for recalling events that have been deferred by the Active Object instance. </td></tr>
<tr>
<td><b>Dependencies</b><br  />
 <a class="el" href="srs_ao.html#REQ-QP-03_20">REQ-QP-03_20</a>, <a class="el" href="srs_ao.html#REQ-QP-03_21">REQ-QP-03_21</a> </td></tr>
</table>
<p><a id="a54_REQ-QP-04_10" name="a54_REQ-QP-04_10"></a> </p>
<h2><a class="anchor" id="REQ-QP-04_10"></a>
REQ-QP-04_10</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-04_10 </th></tr>
<tr style="text-align:left">
<th>The direct posting mechanism shall be <u>reliable</u> </th></tr>
<tr>
<td><b>Description</b><br  />
 "Reliable" event posting means that QP Framework provides <a class="el" href="srs_edm.html#src_edm-guarantee">event delivery guarantee</a> to QP Application. This requirement also means that QP Application is responsible for adequately sizing all event queues (and event pools). </td></tr>
<tr>
<td><b>Dependencies</b><br  />
 <a class="el" href="srs_edm.html#REQ-QP-04_00">REQ-QP-04_00</a> </td></tr>
<tr>
<td><b>Use case</b><br  />
 QP Framework can meet this requirement by detecting all conditions that could prevent a posted event from reaching the recipient Active Object (in particular event queue overflow). In case any such condition occurs, QP Framework shall enter a fail-safe state. That way, QP Application does not need to check whether direct event posting was successful (because continuing execution means that it was). </td></tr>
</table>
<p><a id="a55_REQ-QP-04_20" name="a55_REQ-QP-04_20"></a> </p>
<h2><a class="anchor" id="REQ-QP-04_20"></a>
REQ-QP-04_20</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-04_20 </th></tr>
<tr style="text-align:left">
<th>QP Framework may provide alternative <u>unreliable</u> event posting mechanism without event delivery guarantee </th></tr>
<tr>
<td><b>Description</b><br  />
 The alterative direct event posting mechanism without event delivery guarantee must use a different API than the default mechanism with delivery guarantee. QP Framework still shall detect that a given event cannot be posted, but the framework should pass this information to QP Application instead of entering a fail-safe state. </td></tr>
<tr>
<td><b>Use Case</b><br  />
 Event posting without event delivery mechanism is useful for events that the application can afford to occasionally lose and can apply only "best effort" to handle. </td></tr>
</table>
<p><a id="a56_REQ-QP-04_21" name="a56_REQ-QP-04_21"></a> </p>
<h2><a class="anchor" id="REQ-QP-04_21"></a>
REQ-QP-04_21</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-04_21 </th></tr>
<tr style="text-align:left">
<th>The alternative unreliable event posting mechanism shall <u>not interfere</u> with the default reliable event posting </th></tr>
<tr>
<td><b>Description</b><br  />
 The alterative unreliable event posting must co-exist with the default reliable direct event posting. An example of interference between the two event posting mechanisms is exhausting queue capacity by the unreliable event posting, so that the reliable event posting fails and causes the system to enter fail-safe state. </td></tr>
<tr>
<td><b>Dependencies</b><br  />
 <a class="el" href="srs_edm.html#REQ-QP-04_20">REQ-QP-04_20</a> </td></tr>
<tr>
<td><b>Use Case</b><br  />
 QP Framework can fulfill this requirement by allowing the unreliable posting mechanism to specify a number of entries in the queue that must remain available (a safety margin) to the reliable (default) event posting mechanism. </td></tr>
</table>
<p><a id="a57_REQ-QP-04_50" name="a57_REQ-QP-04_50"></a> </p>
<h2><a class="anchor" id="REQ-QP-04_50"></a>
REQ-QP-04_50</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-04_50 </th></tr>
<tr style="text-align:left">
<th>QP Framework shall provide <u>publish-subscribe</u> event delivery mechanism </th></tr>
<tr>
<td><b>Description</b><br  />
 Publish-subscribe shall use direct event posting (default, reliable variant based on FIFO policy) as the underlying low-level mechanism to multicast the subscribed events. </td></tr>
<tr>
<td><b>Dependencies</b><br  />
 <a class="el" href="srs_edm.html#REQ-QP-04_00">REQ-QP-04_00</a> </td></tr>
</table>
<p><a id="a58_REQ-QP-04_51" name="a58_REQ-QP-04_51"></a> </p>
<h2><a class="anchor" id="REQ-QP-04_51"></a>
REQ-QP-04_51</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-04_51 </th></tr>
<tr style="text-align:left">
<th>QP Framework shall provide initialization of <u>publish-subscribe</u> event delivery mechanism </th></tr>
<tr>
<td><b>Description</b><br  />
 To initialize publish-subscribe delivery mechanism, QP Application must supply the maximum number of event signals that can be subscribed and a memory buffer to store the subscription information. However, the initialization shall be optional, meaning that the QP Application can choose not to perform it. In that case, the feature shall be inactive and shall not cause any waste of resources (RAM). </td></tr>
<tr>
<td><b>Dependencies</b><br  />
 <a class="el" href="srs_edm.html#REQ-QP-04_50">REQ-QP-04_50</a> </td></tr>
</table>
<p><a id="a59_REQ-QP-04_52" name="a59_REQ-QP-04_52"></a> </p>
<h2><a class="anchor" id="REQ-QP-04_52"></a>
REQ-QP-04_52</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-04_52 </th></tr>
<tr style="text-align:left">
<th>QP Framework shall allow Active Object instances to subscribe to a given event signal at run-time. </th></tr>
<tr>
<td><b>Description</b><br  />
 QP Framework shall provide API for Active Objects to subscribe one <a class="el" href="srs_evt.html#srs_evt-sig">event signal</a> at a time. The API shall be callable multiple times by a given Active Object to subscribe to multiple event signals. Event subscription requires initialization of the publish-subscribe feature and attempts to subscribe without prior initialization shall be treated as a programming error. Similarly, subscribing to an already subscribed signal shall be treated as a programming error. </td></tr>
<tr>
<td><b>Dependencies</b><br  />
 <a class="el" href="srs_edm.html#REQ-QP-04_50">REQ-QP-04_50</a> </td></tr>
</table>
<p><a id="a60_REQ-QP-04_53" name="a60_REQ-QP-04_53"></a> </p>
<h2><a class="anchor" id="REQ-QP-04_53"></a>
REQ-QP-04_53</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-04_53 </th></tr>
<tr style="text-align:left">
<th>QP Framework shall allow Active Object instances to unsubscribe from a subscribed event signal at run-time. </th></tr>
<tr>
<td><b>Description</b><br  />
 QP Framework shall provide API for Active Objects to unsubscribe one <a class="el" href="srs_evt.html#srs_evt-sig">event signal</a> at a time. The API shall be callable multiple times by a given Active Object to unsubscribe from multiple event signals. Event un-subscription requires initialization of the publish-subscribe feature and attempts to unsubscribe without prior initialization shall be treated as a programming error. Similarly, unsubscribing from a signal that has not been subscribed shall be treated as a programming error. </td></tr>
<tr>
<td><b>Dependencies</b><br  />
 <a class="el" href="srs_edm.html#REQ-QP-04_50">REQ-QP-04_50</a> </td></tr>
</table>
<p><a id="a61_REQ-QP-04_54" name="a61_REQ-QP-04_54"></a> </p>
<h2><a class="anchor" id="REQ-QP-04_54"></a>
REQ-QP-04_54</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-04_54 </th></tr>
<tr style="text-align:left">
<th>QP Framework shall allow Active Object instances to unsubscribe from all subscribed event signals at run-time. </th></tr>
<tr>
<td><b>Description</b><br  />
 QP Framework shall provide API for Active Objects to unsubscribe from all <a class="el" href="srs_evt.html#srs_evt-sig">event signals</a> at ones. Event un-subscription requires initialization of the publish-subscribe feature and attempts to unsubscribe without prior initialization shall be treated as a programming error. </td></tr>
</table>
<p><a id="a62_REQ-QP-04_55" name="a62_REQ-QP-04_55"></a> </p>
<h2><a class="anchor" id="REQ-QP-04_55"></a>
REQ-QP-04_55</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-04_55 </th></tr>
<tr style="text-align:left">
<th>Event multicasting during publishing shall complete before the processing of the published events. </th></tr>
<tr>
<td><b>Description</b><br  />
 The purpose of this requirement is to prevent event publishing from creating unexpected event sequences when QP Framework runs on top of a <em>preemptive</em> kernel. As specified in <a class="el" href="srs_edm.html#REQ-QP-04_50">REQ-QP-04_50</a>, event multicasting (required when a given event signal is subscribed by multiple Active Objects) uses the default direct event posting mechanism. However, if the priority of the event producer is lower than the priority of the recipient Active Object, direct event posting would normally lead to preemption (before multicasting completes). Such a preemption would then cause the high-priority Active Object to immediately process the published event, which might produce other events. These other events would then appear in the event queues of Active Objects before the originally published event. This would generate a <b>confusing event sequence</b>. </td></tr>
<tr>
<td><b>Dependencies</b><br  />
 <a class="el" href="srs_edm.html#REQ-QP-04_50">REQ-QP-04_50</a> </td></tr>
<tr>
<td><b>Use Case</b><br  />
 QP Framework can fulfill this requirement by preventing preemption during the event multicasting (only needed when QP Framework runs on top of a preemptive kernel). The preemption should be prevented only for the priorities of Active Objects involved in this particular multicasting. An ideal mechanism for that is selective scheduler locking based on priority ceiling protocol. The priority ceiling shall be set to the highest priority subscriber to a given event. </td></tr>
</table>
<p><a id="a63_REQ-QP-04_80" name="a63_REQ-QP-04_80"></a> </p>
<h2><a class="anchor" id="REQ-QP-04_80"></a>
REQ-QP-04_80</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-04_80 </th></tr>
<tr style="text-align:left">
<th>All event delivery mechanisms shall be <u>free of concurrency hazards</u>. </th></tr>
<tr>
<td><b>Description</b><br  />
 "Free of concurrency hazards" means free of such hazards as as race conditions and data races. It also means that QP Framework must ensure that the <a class="el" href="srs_ao.html#srs_ao-curr">current event</a> does not change (e.g., is not corrupted or prematurely recycled) throughout all RTC steps it is involved in. </td></tr>
</table>
<p><a id="a64_REQ-QP-04_81" name="a64_REQ-QP-04_81"></a> </p>
<h2><a class="anchor" id="REQ-QP-04_81"></a>
REQ-QP-04_81</h2>
<table class="doxtable">
<tr>
<th>REQ-QP-04_81 </th></tr>
<tr style="text-align:left">
<th>All event delivery mechanism shall be <u>deterministic</u>. </th></tr>
<tr>
<td><b>Description</b><br  />
 "Deterministic" means that the process of event posting or publishing has a known and constant upper bound of its execution time. In case of event publishing, QP Framework cannot meet this requirement alone because the time of event multicasting depends on the number of subscribers to a given event, so it is not constant. Therefore, QP Application must be designed in such a way that the multicasting time is acceptable. </td></tr>
</table>
<p><span class="prev_button"><a class="el" href="srs_ao.html">Active Objects</a></span><span class="next_button"><a class="el" href="srs_emm.html">Event Memory Management</a></span>  </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="srs.html">Software Requirements Specification</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2024 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 7.3.4</b> &nbsp;|&nbsp; Updated on Thu Mar 21 2024
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2024 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 7.3.4</b> &nbsp;|&nbsp; Updated on Thu Mar 21 2024
</small></address>
    </li>
  </ul>
</div>
</body>
</html>
