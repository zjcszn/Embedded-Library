<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EE MODBUS MASTER: MODBUS Master</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="dox.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EE MODBUS MASTER
   &#160;<span id="projectnumber">v2022 (2022-12-23)</span>
   </div>
   <div id="projectbrief">portable C/C++ MODBUS stack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__mbm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MODBUS Master</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__mbm__cfg"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm__cfg.html">MODBUS Configuration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxMBMFileSubReadReq__t.html">xMBMFileSubReadReq_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxMBMFileSubReadResp__t.html">xMBMFileSubReadResp_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxMBMFileSubWriteReq__t.html">xMBMFileSubWriteReq_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga39ff7ecabacfd2155328f82045368d74"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a></td></tr>
<tr class="separator:ga39ff7ecabacfd2155328f82045368d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaca22d8b649564e798570df743ed2b044"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> { <br />
&#160;&#160;<a class="el" href="group__mbm.html#ggaca22d8b649564e798570df743ed2b044a1b7983bec439e0c938c9fcf4884c4cf7">MBM_STATE_NONE</a>
, <a class="el" href="group__mbm.html#ggaca22d8b649564e798570df743ed2b044a3704db87ad004a0c23f0db8d5bd5558d">MBM_STATE_SEND</a>
, <a class="el" href="group__mbm.html#ggaca22d8b649564e798570df743ed2b044ad65daf91bac311102dbf613549b21b10">MBM_STATE_WAITING</a>
, <a class="el" href="group__mbm.html#ggaca22d8b649564e798570df743ed2b044a4c4bcbc459b13d2b59d224225ff81095">MBM_STATE_DISASSEMBLE</a>
, <br />
&#160;&#160;<a class="el" href="group__mbm.html#ggaca22d8b649564e798570df743ed2b044aefae878247af9f2db939c6c924e34bb9">MBM_STATE_ERROR</a>
, <a class="el" href="group__mbm.html#ggaca22d8b649564e798570df743ed2b044a5c4c54c89d5d940ed32ee8fa0d55d280">MBM_STATE_DONE</a>
<br />
 }</td></tr>
<tr class="separator:gaca22d8b649564e798570df743ed2b044"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa9c3b86a71907fe1450dc1652e5ab9cc"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#gaa9c3b86a71907fe1450dc1652e5ab9cc">eMBMSetSlaveTimeout</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usNMilliSeconds)</td></tr>
<tr class="separator:gaa9c3b86a71907fe1450dc1652e5ab9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf70e17b30721fad9bfa97df32d76c43a"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#gaf70e17b30721fad9bfa97df32d76c43a">eMBMClose</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl)</td></tr>
<tr class="separator:gaf70e17b30721fad9bfa97df32d76c43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38e2186fb377dc6807e34c2978e68d73"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga38e2186fb377dc6807e34c2978e68d73">eMBMGetStatistics</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="structxMBStat.html">xMBStat</a> *pxMBMCurrentStat)</td></tr>
<tr class="separator:ga38e2186fb377dc6807e34c2978e68d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ac98110b158e86c16332df0703121c3"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga1ac98110b158e86c16332df0703121c3">eMBMResetStatistics</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl)</td></tr>
<tr class="separator:ga1ac98110b158e86c16332df0703121c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb1de90f8eafa4321b3a4781854bb74"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga5fb1de90f8eafa4321b3a4781854bb74">eMBMRegisterProtAnalyzer</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, void *pvCtxArg, <a class="el" href="group__mb__cmn.html#gabee7c0c03c5f885dba8f68476be3bab0">pvMBAnalyzerCallbackCB</a> pvMBAnalyzerCallbackFN)</td></tr>
<tr class="separator:ga5fb1de90f8eafa4321b3a4781854bb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga136a52e63da3a4e353203948e737cd42"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga136a52e63da3a4e353203948e737cd42">eMBMReadHoldingRegisters</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usRegStartAddress, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubNRegs, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> arusBufferOut[])</td></tr>
<tr class="separator:ga136a52e63da3a4e353203948e737cd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35ad5b33d0ccc547d7f844554f2de5d2"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga35ad5b33d0ccc547d7f844554f2de5d2">eMBMMaskWriteRegister</a> (<a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usRegAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usANDMask, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usORMask)</td></tr>
<tr class="separator:ga35ad5b33d0ccc547d7f844554f2de5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc2ddc7fda6022ccfda8b94eb2e5394"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#gabdc2ddc7fda6022ccfda8b94eb2e5394">eMBMWriteSingleRegister</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usRegAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usValue)</td></tr>
<tr class="separator:gabdc2ddc7fda6022ccfda8b94eb2e5394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga615a34b18c4e93785125c89de55c3bfa"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga615a34b18c4e93785125c89de55c3bfa">eMBMReadInputRegisters</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usRegStartAddress, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubNRegs, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> arusBufferOut[])</td></tr>
<tr class="separator:ga615a34b18c4e93785125c89de55c3bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e0d9166403d5170e0de3fc365b6deff"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga1e0d9166403d5170e0de3fc365b6deff">eMBMWriteMultipleRegisters</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usRegStartAddress, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubNRegs, const <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> arusBufferIn[])</td></tr>
<tr class="separator:ga1e0d9166403d5170e0de3fc365b6deff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad00eb7be697e8f89a687f4bb22d8cb66"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#gad00eb7be697e8f89a687f4bb22d8cb66">eMBMReadWriteMultipleRegisters</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usWriteRegStartAddress, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubWriteNRegs, const <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> arusBufferIn[], <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usReadRegStartAddress, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubReadNRegs, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> arusBufferOut[])</td></tr>
<tr class="separator:gad00eb7be697e8f89a687f4bb22d8cb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad999f2307357c6c05fcb52c4a06e6a87"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#gad999f2307357c6c05fcb52c4a06e6a87">eMBMReadDiscreteInputs</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usInputStartAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usNInputs, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> arubBufferOut[])</td></tr>
<tr class="separator:gad999f2307357c6c05fcb52c4a06e6a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eeca54955d2ba278a2528808bd9705e"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga0eeca54955d2ba278a2528808bd9705e">eMBMReadCoils</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usCoilStartAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usNCoils, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> arubBufferOut[])</td></tr>
<tr class="separator:ga0eeca54955d2ba278a2528808bd9705e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4441839f7b7f48e8ce0e357db87daa29"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga4441839f7b7f48e8ce0e357db87daa29">eMBMWriteSingleCoil</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usOutputAddress, <a class="el" href="group__mb__port.html#gaf492d2bddcb2befacb3aa03dcdf9aafd">BOOL</a> bOn)</td></tr>
<tr class="separator:ga4441839f7b7f48e8ce0e357db87daa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeceb2922f58c0df0a53d38885305715"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#gaeeceb2922f58c0df0a53d38885305715">eMBMWriteCoils</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usCoilStartAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usNCoils, const <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> arubCoilsIn[])</td></tr>
<tr class="separator:gaeeceb2922f58c0df0a53d38885305715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dcc22b3167c37a3424d0049f12eab6c"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga6dcc22b3167c37a3424d0049f12eab6c">eMBMReadWriteRAWPDU</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucFunctionCode, const <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> arubPayloadIn[], <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubPayloadInLength, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> arubPayloadOut[], <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubPayloadOutLengthMax, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> *pubPayloadOutLength)</td></tr>
<tr class="separator:ga6dcc22b3167c37a3424d0049f12eab6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga464ea91b34f860c88ca50b6795984e7a"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga464ea91b34f860c88ca50b6795984e7a">eMBMReportSlaveID</a> (<a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> arubBufferOut[], <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubBufferMax, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> *pubLength)</td></tr>
<tr class="separator:ga464ea91b34f860c88ca50b6795984e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa09b4525fdd9d221c9d48d40ba56f3b8"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#gaa09b4525fdd9d221c9d48d40ba56f3b8">eMBMReadFileRecord</a> (<a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, const <a class="el" href="structxMBMFileSubReadReq__t.html">xMBMFileSubReadReq_t</a> arxSubRequests[], <a class="el" href="structxMBMFileSubReadResp__t.html">xMBMFileSubReadResp_t</a> arxSubResponses[], <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usNSubRequests)</td></tr>
<tr class="separator:gaa09b4525fdd9d221c9d48d40ba56f3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19014cb4fe74a3f10ad344755d0441ec"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga19014cb4fe74a3f10ad344755d0441ec">eMBMWriteFileRecord</a> (<a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, const <a class="el" href="structxMBMFileSubWriteReq__t.html">xMBMFileSubWriteReq_t</a> arxSubRequests[], <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usNSubRequests)</td></tr>
<tr class="separator:ga19014cb4fe74a3f10ad344755d0441ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3658094a1c51a51ac5bdb1972974b62e"><td class="memItemLeft" align="right" valign="top">_DLLEXP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga3658094a1c51a51ac5bdb1972974b62e">vMBMReadHoldingRegistersPolled</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usRegStartAddress, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubNRegs, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> arusBufferOut[], <a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *peState, <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *peStatus)</td></tr>
<tr class="separator:ga3658094a1c51a51ac5bdb1972974b62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2b1feaff5f800c554ac1701e11607ac"><td class="memItemLeft" align="right" valign="top">_DLLEXP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#gad2b1feaff5f800c554ac1701e11607ac">vMBMMaskWriteRegisterPolled</a> (<a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usRegAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usANDMask, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usORMask, <a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *peState, <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *peStatus)</td></tr>
<tr class="separator:gad2b1feaff5f800c554ac1701e11607ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ae6bcc86348b59e12fdfa41738b3221"><td class="memItemLeft" align="right" valign="top">_DLLEXP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga9ae6bcc86348b59e12fdfa41738b3221">vMBMWriteSingleRegisterPolled</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usRegAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usValue, <a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *peState, <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *peStatus)</td></tr>
<tr class="separator:ga9ae6bcc86348b59e12fdfa41738b3221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64900771ca6c95c57df5e6a7040da202"><td class="memItemLeft" align="right" valign="top">_DLLEXP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga64900771ca6c95c57df5e6a7040da202">vMBMReadInputRegistersPolled</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usRegStartAddress, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubNRegs, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> arusBufferOut[], <a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *peState, <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *peStatus)</td></tr>
<tr class="separator:ga64900771ca6c95c57df5e6a7040da202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02d5f48ea8d2fa5b2290572098dd6d40"><td class="memItemLeft" align="right" valign="top">_DLLEXP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga02d5f48ea8d2fa5b2290572098dd6d40">vMBMWriteMultipleRegistersPolled</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usRegStartAddress, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubNRegs, const <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> arusBufferIn[], <a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *peState, <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *peStatus)</td></tr>
<tr class="separator:ga02d5f48ea8d2fa5b2290572098dd6d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaacad64422c656aaacfdff4bf8486a6f"><td class="memItemLeft" align="right" valign="top">_DLLEXP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#gaaacad64422c656aaacfdff4bf8486a6f">vMBMReadWriteMultipleRegistersPolled</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usWriteRegStartAddress, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubWriteNRegs, const <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> arusBufferIn[], <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usReadRegStartAddress, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubReadNRegs, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> arusBufferOut[], <a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *peState, <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *peStatus)</td></tr>
<tr class="separator:gaaacad64422c656aaacfdff4bf8486a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65d6f42f061c62aa8da37d6110396feb"><td class="memItemLeft" align="right" valign="top">_DLLEXP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga65d6f42f061c62aa8da37d6110396feb">vMBMReadDiscreteInputsPolled</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usInputStartAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usNInputs, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> arubBufferOut[], <a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *peState, <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *peStatus)</td></tr>
<tr class="separator:ga65d6f42f061c62aa8da37d6110396feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aef2e1e004552811a4232d2afec61f4"><td class="memItemLeft" align="right" valign="top">_DLLEXP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga5aef2e1e004552811a4232d2afec61f4">vMBMReadCoilsPolled</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usCoilStartAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usNCoils, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> arubBufferOut[], <a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *peState, <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *peStatus)</td></tr>
<tr class="separator:ga5aef2e1e004552811a4232d2afec61f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga292993bce43830d6f75a535c7d6fd476"><td class="memItemLeft" align="right" valign="top">_DLLEXP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga292993bce43830d6f75a535c7d6fd476">vMBMWriteSingleCoilPolled</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usOutputAddress, <a class="el" href="group__mb__port.html#gaf492d2bddcb2befacb3aa03dcdf9aafd">BOOL</a> bOn, <a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *peState, <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *peStatus)</td></tr>
<tr class="separator:ga292993bce43830d6f75a535c7d6fd476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a3ad933943a25e382fcca41714c3f01"><td class="memItemLeft" align="right" valign="top">_DLLEXP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga3a3ad933943a25e382fcca41714c3f01">vMBMWriteCoilsPolled</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usCoilStartAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usNCoils, const <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> arubCoilsIn[], <a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *peState, <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *peStatus)</td></tr>
<tr class="separator:ga3a3ad933943a25e382fcca41714c3f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea745bf7819e92758d156c8167459904"><td class="memItemLeft" align="right" valign="top">_DLLEXP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#gaea745bf7819e92758d156c8167459904">vMBMReadWriteRAWPDUPolled</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucFunctionCode, const <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> arubPayloadIn[], <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubPayloadInLength, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> arubPayloadOut[], <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubPayloadOutLengthMax, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> *pubPayloadOutLength, <a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *peState, <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *peStatus)</td></tr>
<tr class="separator:gaea745bf7819e92758d156c8167459904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga498439f80cf54f3f6c0e682f13b910e9"><td class="memItemLeft" align="right" valign="top">_DLLEXP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga498439f80cf54f3f6c0e682f13b910e9">vMBMReportSlaveID</a> (<a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> arubBufferOut[], <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> ubBufferMax, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> *pubLength, <a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *peState, <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *peStatus)</td></tr>
<tr class="separator:ga498439f80cf54f3f6c0e682f13b910e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga610ec05392e913a2088c577718e5da89"><td class="memItemLeft" align="right" valign="top">_DLLEXP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga610ec05392e913a2088c577718e5da89">vMBMReadFileRecordPolled</a> (<a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, const <a class="el" href="structxMBMFileSubReadReq__t.html">xMBMFileSubReadReq_t</a> arxSubRequests[], <a class="el" href="structxMBMFileSubReadResp__t.html">xMBMFileSubReadResp_t</a> arxSubResponses[], <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usNSubRequests, <a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *peState, <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *peStatus)</td></tr>
<tr class="separator:ga610ec05392e913a2088c577718e5da89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33a8c0c949f81237ac0bcac9a5d9a6ae"><td class="memItemLeft" align="right" valign="top">_DLLEXP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga33a8c0c949f81237ac0bcac9a5d9a6ae">vMBMWriteFileRecordPolled</a> (<a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xHdl, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucSlaveAddress, const <a class="el" href="structxMBMFileSubWriteReq__t.html">xMBMFileSubWriteReq_t</a> arxSubRequests[], <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usNSubRequests, <a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *peState, <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *peStatus)</td></tr>
<tr class="separator:ga33a8c0c949f81237ac0bcac9a5d9a6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d15a39b8ea45d2ab50e5951615e8ed3"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga6d15a39b8ea45d2ab50e5951615e8ed3">eMBMSerialInit</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> *pxHdl, <a class="el" href="group__mb__cmn.html#ga7a4a53c89f13d601f2830fea508e2307">eMBSerialMode</a> eMode, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucPort, <a class="el" href="group__mb__port.html#gaf632da489ebc3708ec3ab6791ee53fa4">ULONG</a> ulBaudRate, <a class="el" href="group__mb__cmn.html#gab7daf28bb4d8c43df08704d918323d42">eMBSerialParity</a> eParity)</td></tr>
<tr class="separator:ga6d15a39b8ea45d2ab50e5951615e8ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac74f170aa8f7e71cb0ca0e0f32cb5a02"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#gac74f170aa8f7e71cb0ca0e0f32cb5a02">eMBMSerialInitExt</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> *pxHdl, <a class="el" href="group__mb__cmn.html#ga7a4a53c89f13d601f2830fea508e2307">eMBSerialMode</a> eMode, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucPort, <a class="el" href="group__mb__port.html#gaf632da489ebc3708ec3ab6791ee53fa4">ULONG</a> ulBaudRate, <a class="el" href="group__mb__cmn.html#gab7daf28bb4d8c43df08704d918323d42">eMBSerialParity</a> eParity, <a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a> ucStopBits)</td></tr>
<tr class="separator:gac74f170aa8f7e71cb0ca0e0f32cb5a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ed45e6af7c0078901bc460b136f82cc"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga8ed45e6af7c0078901bc460b136f82cc">eMBMTCPInit</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> *pxHdl)</td></tr>
<tr class="separator:ga8ed45e6af7c0078901bc460b136f82cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bb69ce870efbcebcae69d62bc7ec93e"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga8bb69ce870efbcebcae69d62bc7ec93e">eMBMTCPConnect</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, const <a class="el" href="group__mb__port.html#gaebb9e13210d88d43e32e735ada43a425">CHAR</a> *pcTCPClientAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usTCPPort)</td></tr>
<tr class="separator:ga8bb69ce870efbcebcae69d62bc7ec93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6f5c0ada100b309ba32c06ef646da8c"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#gad6f5c0ada100b309ba32c06ef646da8c">eMBMTCPDisconnect</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl)</td></tr>
<tr class="separator:gad6f5c0ada100b309ba32c06ef646da8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d07d81e5f395979314919d2634af520"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#ga8d07d81e5f395979314919d2634af520">eMBMUDPInit</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> *pxHdl, const <a class="el" href="group__mb__port.html#gaebb9e13210d88d43e32e735ada43a425">CHAR</a> *pcUDPBindAddress, <a class="el" href="group__mb__port.html#ga2a3e0cda5f1249bef6db47c5eb8e3813">LONG</a> uUDPListenPort)</td></tr>
<tr class="separator:ga8d07d81e5f395979314919d2634af520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafab766276af3a117f7b1969f3081158"><td class="memItemLeft" align="right" valign="top">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbm.html#gaafab766276af3a117f7b1969f3081158">eMBMUDPSetSlave</a> (<a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> xHdl, const <a class="el" href="group__mb__port.html#gaebb9e13210d88d43e32e735ada43a425">CHAR</a> *pcUDPClientAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usUDPSlavePort)</td></tr>
<tr class="separator:gaafab766276af3a117f7b1969f3081158"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbm.h&quot;</span> </div>
</div><!-- fragment --><p>The API documentation is splitted into different parts. A typical application will only to have use the API function shown in this module. The most important functions are the functions for opening and closing a MODBUS instances. There are different function depending on the type of transmission you are going to use. For serial transmission modes the function eMBMSerialInit should be used. For MODBUS/TCP the function eMBMTCPInit should be used.<br  />
 After a new instance has been created the API function for querying a slave can be used. There are two different kind of API functions. The first one are blocking API functions which can be used in case of an RTOS or a single instance of the stack. The non blocking API functions can be used in any other case.</p>
<p><b>Using a blocking version of the API:</b><br  />
 In this example we use a single master which tries to read 5 holding registers starting at address 10 from the slave 1.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">MBMExReadHoldingBlockingAPI( <span class="keywordtype">void</span> )</div>
<div class="line">{</div>
<div class="line">    eMBMErrorCode   eStatus;</div>
<div class="line">    <a class="code" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>      xMBMMasterHdl1;</div>
<div class="line">    <a class="code" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>          usNRegs[5];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Initialize MODBUS stack here. */</span></div>
<div class="line">    ...eStatus = <a class="code" href="group__mbm.html#ga136a52e63da3a4e353203948e737cd42">eMBMReadHoldingRegisters</a>( xMBMMasterHdl1, 1, 10, 5, usNRegs );</div>
<div class="line">    <span class="keywordflow">if</span>( MBM_ENOERR == eStatus )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* You can safely access now usNRegs. */</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__mb__port_html_ga5850d5316caf7f4cedd742fdf8cd7c02"><div class="ttname"><a href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a></div><div class="ttdeci">unsigned short USHORT</div><div class="ttdoc">An unsigned short value holding values from 0 to 65535.</div><div class="ttdef"><b>Definition:</b> mbport.h:107</div></div>
<div class="ttc" id="agroup__mbm_html_ga136a52e63da3a4e353203948e737cd42"><div class="ttname"><a href="group__mbm.html#ga136a52e63da3a4e353203948e737cd42">eMBMReadHoldingRegisters</a></div><div class="ttdeci">_DLLEXP eMBErrorCode eMBMReadHoldingRegisters(xMBMHandle xHdl, UCHAR ucSlaveAddress, USHORT usRegStartAddress, UBYTE ubNRegs, USHORT arusBufferOut[])</div><div class="ttdoc">Read Holding Registers from a slave using the MODBUS function code 0x03</div></div>
<div class="ttc" id="agroup__mbm_html_ga39ff7ecabacfd2155328f82045368d74"><div class="ttname"><a href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a></div><div class="ttdeci">void * xMBMHandle</div><div class="ttdoc">A handle to a MODBUS master instance.</div><div class="ttdef"><b>Definition:</b> mbm.h:41</div></div>
</div><!-- fragment --><p> <b>Using a non-blocking version of the API:</b><br  />
 In this example we assume two master stacks using two different serial ports. Furthermore no RTOS is available and therefore the polled version of the funtions have to be used. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">MBMExReadHoldingNonBlockingAPI( <span class="keywordtype">void</span> )</div>
<div class="line">{</div>
<div class="line">    eMBMErrorCode   eStatus1, eStatus2;</div>
<div class="line">    <a class="code" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a>  eState1;</div>
<div class="line">    <a class="code" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a>  eState2;</div>
<div class="line">    <a class="code" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>      xMBMMasterHdl1;</div>
<div class="line">    <a class="code" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>      xMBMMasterHdl2;</div>
<div class="line">    <a class="code" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>          usNRegs1[5], usNRegs2[2];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Initialize MODBUS stacks here. */</span></div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">/* Don&#39;t forget to initialize the state variables. */</span></div>
<div class="line">    eState1 = eState2 = <a class="code" href="group__mbm.html#ggaca22d8b649564e798570df743ed2b044a1b7983bec439e0c938c9fcf4884c4cf7">MBM_STATE_NONE</a>;</div>
<div class="line">   </div>
<div class="line">    <span class="comment">/* Perform initial poll */</span> </div>
<div class="line">    <a class="code" href="group__mbm.html#ga3658094a1c51a51ac5bdb1972974b62e">vMBMReadHoldingRegistersPolled</a>( xMBMMasterHdl1, 1, 10, 5, usNRegs1, &amp;eState1, &amp;eStatus1 );</div>
<div class="line">    <a class="code" href="group__mbm.html#ga3658094a1c51a51ac5bdb1972974b62e">vMBMReadHoldingRegistersPolled</a>( xMBMMasterHdl2, 23, 7, 2, usNRegs2, &amp;eState2, &amp;eStatus2 );</div>
<div class="line">    <span class="keywordflow">do</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>( <a class="code" href="group__mbm.html#ggaca22d8b649564e798570df743ed2b044a1b7983bec439e0c938c9fcf4884c4cf7">MBM_STATE_NONE</a> != eState1 )</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="group__mbm.html#ga3658094a1c51a51ac5bdb1972974b62e">vMBMReadHoldingRegistersPolled</a>( xMBMMasterHdl1, 1, 10, 5, usNRegs1, &amp;eState1, &amp;eStatus1 );</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span>( <a class="code" href="group__mbm.html#ggaca22d8b649564e798570df743ed2b044a1b7983bec439e0c938c9fcf4884c4cf7">MBM_STATE_NONE</a> != eState2 )</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="group__mbm.html#ga3658094a1c51a51ac5bdb1972974b62e">vMBMReadHoldingRegistersPolled</a>( xMBMMasterHdl2, 23, 7, 2, usNRegs2, &amp;eState2, &amp;eStatus2 );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">while</span>( ( eState1 != <a class="code" href="group__mbm.html#ggaca22d8b649564e798570df743ed2b044a5c4c54c89d5d940ed32ee8fa0d55d280">MBM_STATE_DONE</a> ) || ( eState2 != <a class="code" href="group__mbm.html#ggaca22d8b649564e798570df743ed2b044a5c4c54c89d5d940ed32ee8fa0d55d280">MBM_STATE_DONE</a> ) );</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>( MBM_ENOERR == eStatus1 )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* You can safely access now usNRegs1. */</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span>( MBM_ENOERR == eStatus2 )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* You can safely access now usNRegs2. */</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__mbm_html_ga3658094a1c51a51ac5bdb1972974b62e"><div class="ttname"><a href="group__mbm.html#ga3658094a1c51a51ac5bdb1972974b62e">vMBMReadHoldingRegistersPolled</a></div><div class="ttdeci">_DLLEXP void vMBMReadHoldingRegistersPolled(xMBMHandle xHdl, UCHAR ucSlaveAddress, USHORT usRegStartAddress, UBYTE ubNRegs, USHORT arusBufferOut[], eMBMQueryState *peState, eMBErrorCode *peStatus)</div><div class="ttdoc">Read Holding Registers from a slave using the MODBUS function code 0x03 with the Non-Blocking API.</div></div>
<div class="ttc" id="agroup__mbm_html_gaca22d8b649564e798570df743ed2b044"><div class="ttname"><a href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a></div><div class="ttdeci">eMBMQueryState</div><div class="ttdoc">States used by the MODBUS stack internally.</div><div class="ttdef"><b>Definition:</b> mbm.h:49</div></div>
<div class="ttc" id="agroup__mbm_html_ggaca22d8b649564e798570df743ed2b044a1b7983bec439e0c938c9fcf4884c4cf7"><div class="ttname"><a href="group__mbm.html#ggaca22d8b649564e798570df743ed2b044a1b7983bec439e0c938c9fcf4884c4cf7">MBM_STATE_NONE</a></div><div class="ttdeci">@ MBM_STATE_NONE</div><div class="ttdef"><b>Definition:</b> mbm.h:50</div></div>
<div class="ttc" id="agroup__mbm_html_ggaca22d8b649564e798570df743ed2b044a5c4c54c89d5d940ed32ee8fa0d55d280"><div class="ttname"><a href="group__mbm.html#ggaca22d8b649564e798570df743ed2b044a5c4c54c89d5d940ed32ee8fa0d55d280">MBM_STATE_DONE</a></div><div class="ttdeci">@ MBM_STATE_DONE</div><div class="ttdef"><b>Definition:</b> mbm.h:55</div></div>
</div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a id="ga39ff7ecabacfd2155328f82045368d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39ff7ecabacfd2155328f82045368d74">&#9670;&nbsp;</a></span>xMBMHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle to a MODBUS master instance. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaca22d8b649564e798570df743ed2b044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca22d8b649564e798570df743ed2b044">&#9670;&nbsp;</a></span>eMBMQueryState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>States used by the MODBUS stack internally. </p>
<dl class="section note"><dt>Note</dt><dd>These values are not important for the user and should not be accessed or used. They are used by the polled versions of the API calls. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaca22d8b649564e798570df743ed2b044a1b7983bec439e0c938c9fcf4884c4cf7"></a>MBM_STATE_NONE&#160;</td><td class="fielddoc"><p>Not yet started. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaca22d8b649564e798570df743ed2b044a3704db87ad004a0c23f0db8d5bd5558d"></a>MBM_STATE_SEND&#160;</td><td class="fielddoc"><p>Frame will be sent. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaca22d8b649564e798570df743ed2b044ad65daf91bac311102dbf613549b21b10"></a>MBM_STATE_WAITING&#160;</td><td class="fielddoc"><p>Waiting for an event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaca22d8b649564e798570df743ed2b044a4c4bcbc459b13d2b59d224225ff81095"></a>MBM_STATE_DISASSEMBLE&#160;</td><td class="fielddoc"><p>Disassembling the frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaca22d8b649564e798570df743ed2b044aefae878247af9f2db939c6c924e34bb9"></a>MBM_STATE_ERROR&#160;</td><td class="fielddoc"><p>An error occurred. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaca22d8b649564e798570df743ed2b044a5c4c54c89d5d940ed32ee8fa0d55d280"></a>MBM_STATE_DONE&#160;</td><td class="fielddoc"><p>We are done processing the request. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf70e17b30721fad9bfa97df32d76c43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf70e17b30721fad9bfa97df32d76c43a">&#9670;&nbsp;</a></span>eMBMClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the stack. </p>
<p>Shutdown the master stack. This function should not be called when there are still pending requests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A handle for a MODBUS master instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the stack has been shut down. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AVR-ATMEGA_ATMELSTUDIO_BARE_2demo_8c-example.html#a10">AVR-ATMEGA_ATMELSTUDIO_BARE/demo.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga38e2186fb377dc6807e34c2978e68d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38e2186fb377dc6807e34c2978e68d73">&#9670;&nbsp;</a></span>eMBMGetStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMGetStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structxMBStat.html">xMBStat</a> *&#160;</td>
          <td class="paramname"><em>pxMBMCurrentStat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the current master statistics. </p>
<p>This function populates the argument pxMBMCurrentStat with the current internal counters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">pxMBMCurrentStat</td><td>A pointer to an (potentially unitialized) eMBMStat datastructure. When the return value is eMBErrorCode::MB_ENOERR this data structure holds a copy of the internal counters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if successful. In case of an invalid argument the function returns eMBErrorCode::MB_EINVAL. </dd></dl>

</div>
</div>
<a id="ga35ad5b33d0ccc547d7f844554f2de5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35ad5b33d0ccc547d7f844554f2de5d2">&#9670;&nbsp;</a></span>eMBMMaskWriteRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMMaskWriteRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usRegAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usANDMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usORMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Mask Single Register</em> in a slave using the MODBUS function code <b>0x16</b>. </p>
<p>After a write to a register the content of the register is modified as following. New Content = (Current Content AND usANDMask) OR (usORMask AND (NOT usANDMask))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. Note that a broadcast address is not allowed for a function which expects a response. </td></tr>
    <tr><td class="paramname">usRegAddress</td><td>The register address to write. </td></tr>
    <tr><td class="paramname">usANDMask</td><td>AND mask </td></tr>
    <tr><td class="paramname">usORMask</td><td>OR mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the slave responded within the timeout and the the reply conforms to the MODBUS protocol specification. If the slave did not respond within the timeout the function returns eMBErrorCode::MB_ETIMEDOUT. Any other errors are IO errors. </dd></dl>

</div>
</div>
<a id="ga0eeca54955d2ba278a2528808bd9705e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eeca54955d2ba278a2528808bd9705e">&#9670;&nbsp;</a></span>eMBMReadCoils()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMReadCoils </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usCoilStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usNCoils</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>arubBufferOut</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Read Coils</em> from a slave using the MODBUS function code <b>0x01</b> </p>
<p>The coils are packed as one coil per bit. Statis is 1=ON and 0=OFF. The LSB of the first data byte contains the coil addressed in the query. The other coils follow toward the high order of the byte. If the input quantity is not a multiple of eight the final data byte is padded with zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">usCoilStartAddress</td><td>Address of first coil. </td></tr>
    <tr><td class="paramname">usNCoils</td><td>Number of coils to read. </td></tr>
    <tr><td class="paramname">arubBufferOut</td><td>An array with a size of at least usNCoils/8 bytes. The size must be rounded up to next integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the slave responded within the timeout and the the reply conforms to the MODBUS protocol specification. In this case the array arubBufferIn contains the values returned by the slave. In case of an exception from the slave any of the MODBUS exceptions can be returned. If the slave did not respond within the timeout the function returns eMBErrorCode::MB_ETIMEDOUT. </dd></dl>

</div>
</div>
<a id="gad999f2307357c6c05fcb52c4a06e6a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad999f2307357c6c05fcb52c4a06e6a87">&#9670;&nbsp;</a></span>eMBMReadDiscreteInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMReadDiscreteInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usInputStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usNInputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>arubBufferOut</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Read Discrete Inputs</em> from a slave using the MODBUS function code <b>0x02</b> </p>
<p>The discrete inputs are packed as one input per bit. Statis is 1=ON and 0=OFF. The LSB of the first data byte contains the input addressed in the query. The other inputs follow toward the high order of the byte. If the input quantity is not a multiple of eight the final data byte is padded with zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">usInputStartAddress</td><td>Address of first discrete input. </td></tr>
    <tr><td class="paramname">usNInputs</td><td>Number of discrete inputs to read. </td></tr>
    <tr><td class="paramname">arubBufferOut</td><td>An array with a size of at least usNInputs/8 bytes. The size must be rounded up to next integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the slave responded within the timeout and the the reply conforms to the MODBUS protocol specification. In this case the array arubBufferIn contains the values returned by the slave. In case of an exception from the slave any of the MODBUS exceptions can be returned. If the slave did not respond within the timeout the function returns eMBErrorCode::MB_ETIMEDOUT. </dd></dl>

</div>
</div>
<a id="gaa09b4525fdd9d221c9d48d40ba56f3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa09b4525fdd9d221c9d48d40ba56f3b8">&#9670;&nbsp;</a></span>eMBMReadFileRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMReadFileRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structxMBMFileSubReadReq__t.html">xMBMFileSubReadReq_t</a>&#160;</td>
          <td class="paramname"><em>arxSubRequests</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structxMBMFileSubReadResp__t.html">xMBMFileSubReadResp_t</a>&#160;</td>
          <td class="paramname"><em>arxSubResponses</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usNSubRequests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>)Read File Record</em> from a MODBUS slave with function code <b>0x14</b> </p>
<p>This function issues a read file record request. The caller of this function is required to provide an (possibly unitialized) array of arxSubResponses. The size of this array must be equal or larger than the number of sub requests within arxSubRequests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">arxSubRequests</td><td>Sub requests for file records. </td></tr>
    <tr><td class="paramname">arxSubResponses</td><td>A sub response for every requested arxSubRequests. </td></tr>
    <tr><td class="paramname">usNSubRequests</td><td>Size of the arxSubRequests arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the read file record command was successfull. If the arguments are not valid, e.g the number of sub requests would exceed the maximum length of a MODBUS frame, the function returns eMBErrorCode::MB_EINVAL. In case of an exception returned by the slave any of the MODBUS exceptions can be returned. If the slave did not respond within the timeout the function returns eMBErrorCode::MB_ETIMEDOUT. </dd></dl>

</div>
</div>
<a id="ga136a52e63da3a4e353203948e737cd42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga136a52e63da3a4e353203948e737cd42">&#9670;&nbsp;</a></span>eMBMReadHoldingRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMReadHoldingRegisters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usRegStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubNRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>arusBufferOut</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Read Holding Registers</em> from a slave using the MODBUS function code <b>0x03</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. Note that a broadcast address is not allowed for a function which expects a response. </td></tr>
    <tr><td class="paramname">usRegStartAddress</td><td>The first holding register to be read. We use protocol addresses starting at zero. </td></tr>
    <tr><td class="paramname">ubNRegs</td><td>Number of registers to read. </td></tr>
    <tr><td class="paramname">arusBufferOut</td><td>An array of USHORT values of at least ubNRegs elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the slave responded within the timeout and the the reply conforms to the MODBUS protocol specification. In this case the array arusBufferOut contains the values returned by the slave. In case of an exception from the slave any of the MODBUS exceptions can be returned. If the slave did not respond within the timeout the function returns eMBErrorCode::MB_ETIMEDOUT. Any other errors are IO errors. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AVR-ATMEGA_ATMELSTUDIO_BARE_2demo_8c-example.html#a5">AVR-ATMEGA_ATMELSTUDIO_BARE/demo.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga615a34b18c4e93785125c89de55c3bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga615a34b18c4e93785125c89de55c3bfa">&#9670;&nbsp;</a></span>eMBMReadInputRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMReadInputRegisters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usRegStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubNRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>arusBufferOut</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Read Input Registers</em> from a slave using the MODBUS function code <b>0x04</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. Not that a broadcast address is not allowed. </td></tr>
    <tr><td class="paramname">usRegStartAddress</td><td>First register to read. </td></tr>
    <tr><td class="paramname">ubNRegs</td><td>Numer of registers to read. </td></tr>
    <tr><td class="paramname">arusBufferOut</td><td>An array of USHORT values of at least ubNRegs elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the slave responded within the timeout and the the reply conforms to the MODBUS protocol specification. In this case the array arusBufferOut contains the values returned by the slave. In case of an exception from the slave any of the MODBUS exceptions can be returned. If the slave did not respond within the timeout the function returns eMBErrorCode::MB_ETIMEDOUT. Any other errors are IO errors. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AVR-ATMEGA_ATMELSTUDIO_BARE_2demo_8c-example.html#a7">AVR-ATMEGA_ATMELSTUDIO_BARE/demo.c</a>.</dd>
</dl>

</div>
</div>
<a id="gad00eb7be697e8f89a687f4bb22d8cb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad00eb7be697e8f89a687f4bb22d8cb66">&#9670;&nbsp;</a></span>eMBMReadWriteMultipleRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMReadWriteMultipleRegisters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usWriteRegStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubWriteNRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>arusBufferIn</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usReadRegStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubReadNRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>arusBufferOut</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Read/Write Multiple Registers</em> from a slave using the MODBUS function code <b>0x17</b> </p>
<dl class="section note"><dt>Note</dt><dd>The pointers arusBufferIn and arusBufferOut can point to the same memory location. In this case the old contents is overwritten with the returned registers values.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">usWriteRegStartAddress</td><td>First register to write on the slave. </td></tr>
    <tr><td class="paramname">ubWriteNRegs</td><td>Number of registers to write. </td></tr>
    <tr><td class="paramname">arusBufferIn</td><td>An Array of USHORT values of ubWriteNRegs elements which should be written on the slave. </td></tr>
    <tr><td class="paramname">usReadRegStartAddress</td><td>First register to read from the slave. </td></tr>
    <tr><td class="paramname">ubReadNRegs</td><td>Number of registers to read. </td></tr>
    <tr><td class="paramname">arusBufferOut</td><td>An Array of ubReadNRegs elements where the registers values returned by the slave should be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the slave responded within the timeout and the the reply conforms to the MODBUS protocol specification. In this case the array arusBufferOut contains the values returned by the slave. In case of an exception from the slave any of the MODBUS exceptions can be returned. If the slave did not respond within the timeout the function returns eMBErrorCode::MB_ETIMEDOUT. Any other errors are IO errors. </dd></dl>

</div>
</div>
<a id="ga6dcc22b3167c37a3424d0049f12eab6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dcc22b3167c37a3424d0049f12eab6c">&#9670;&nbsp;</a></span>eMBMReadWriteRAWPDU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMReadWriteRAWPDU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucFunctionCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>arubPayloadIn</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubPayloadInLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>arubPayloadOut</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubPayloadOutLengthMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> *&#160;</td>
          <td class="paramname"><em>pubPayloadOutLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function for sending raw MODBUS PDUs to a MODBUS slave. This function can be used if you want to transport custom data over a MODBUS connection or for briding other protocols. Please note that of course most standard slaves won't know how to deal with these custom data payload and therefore its use should be limited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">ucFunctionCode</td><td>MODBUS function code used for transport. Must be between 1 and 127. Recommend values are between 65-72 and 100-110. </td></tr>
    <tr><td class="paramname">arubPayloadIn</td><td>MODBUS request which will be sent to the slave. </td></tr>
    <tr><td class="paramname">ubPayloadInLength</td><td>Length of MODBUS request. Maximum is 252 bytes. </td></tr>
    <tr><td class="paramname">arubPayloadOut</td><td>Holds the MODBUS response sent by the slave. arubPayloadOut can be <code>NULL</code> is ubPayloadOutLengthMax is set to zero. </td></tr>
    <tr><td class="paramname">ubPayloadOutLengthMax</td><td>Size of the buffer arubPayloadOut in bytes. If the slave response exceeds the number of bytes available in the buffer the function returns eMBErrorCode::MB_EINVAL. </td></tr>
    <tr><td class="paramname">pubPayloadOutLength</td><td>Actual number of bytes returned by the slave. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the slave responded within the timeout and the the reply conforms to the MODBUS protocol specification. If the input arguments are invalid, for example arubPayloadIn is a <code>NULL</code> pointer, the function returns eMBErrorCode::MB_EINVAL. In case of an exception from the slave any of the MODBUS exceptions can be returned. If the slave did not respond within the timeout the function returns eMBErrorCode::MB_ETIMEDOUT. </dd></dl>

</div>
</div>
<a id="ga5fb1de90f8eafa4321b3a4781854bb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fb1de90f8eafa4321b3a4781854bb74">&#9670;&nbsp;</a></span>eMBMRegisterProtAnalyzer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMRegisterProtAnalyzer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvCtxArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#gabee7c0c03c5f885dba8f68476be3bab0">pvMBAnalyzerCallbackCB</a>&#160;</td>
          <td class="paramname"><em>pvMBAnalyzerCallbackFN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an protocol analyzer. </p>
<p>If a protocol analyzer has been registered a callback is made whenever a frame has been sent or received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">pvMBAnalyzerCallbackFN</td><td>A valid pointer to a callback handler or <code>NULL</code> if the analyzer should be removed. </td></tr>
    <tr><td class="paramname">pvCtxArg</td><td>A user defined context. Can be <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the analyzer has been added or removed. eMBErrorCode::MB_EINVAL in case of an invalid MODBUS handle. </dd></dl>

</div>
</div>
<a id="ga464ea91b34f860c88ca50b6795984e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga464ea91b34f860c88ca50b6795984e7a">&#9670;&nbsp;</a></span>eMBMReportSlaveID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMReportSlaveID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>arubBufferOut</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubBufferMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> *&#160;</td>
          <td class="paramname"><em>pubLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Report slave ID</em> from a MODBUS slave with function code <b>0x11</b> </p>
<p>This function issues the report slave id command to a MODBUS slave. The response is then stored in the buffer provided by arubBufferOut where the caller has to allocate sufficient space. The maximum amount of space available is determined by ubBufferMax. If there is not enough space available the function returns eMBErrorCode::MB_ENORES.</p>
<p>There is no chance for the MODBUS stack to tell something about the content since the content is vendor specific.</p>
<dl class="section note"><dt>Note</dt><dd>There are some non vendor specific fields but most vendors do not implement them correctly. Therefore we have completely avoided interpreting the data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">arubBufferOut</td><td>Buffer which can hold ubBufferMax bytes. </td></tr>
    <tr><td class="paramname">ubBufferMax</td><td>Size of buffer. </td></tr>
    <tr><td class="paramname">pubLength</td><td>If the call succeeds contains the number of bytes written to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the slave report command succeeded. If the buffer does not have enough space the function returns eMBErrorCode::MB_ENORES. If any of the input arguments are invalid or the buffer are <code>NULL</code> the function return eMBErrorCode::MB_EINVAL. In case of an exception from the slave any of the MODBUS exceptions can be returned. If the slave did not respond within the timeout the function returns eMBErrorCode::MB_ETIMEDOUT. </dd></dl>

</div>
</div>
<a id="ga1ac98110b158e86c16332df0703121c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ac98110b158e86c16332df0703121c3">&#9670;&nbsp;</a></span>eMBMResetStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMResetStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the current statistic counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if successful. In case of an invalid argument the function returns eMBErrorCode::MB_EINVAL. </dd></dl>

</div>
</div>
<a id="ga6d15a39b8ea45d2ab50e5951615e8ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d15a39b8ea45d2ab50e5951615e8ed3">&#9670;&nbsp;</a></span>eMBMSerialInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMSerialInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> *&#160;</td>
          <td class="paramname"><em>pxHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga7a4a53c89f13d601f2830fea508e2307">eMBSerialMode</a>&#160;</td>
          <td class="paramname"><em>eMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#gaf632da489ebc3708ec3ab6791ee53fa4">ULONG</a>&#160;</td>
          <td class="paramname"><em>ulBaudRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#gab7daf28bb4d8c43df08704d918323d42">eMBSerialParity</a>&#160;</td>
          <td class="paramname"><em>eParity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instances for a serial MODBUS master instance using either ASCII or RTU transmission mode. </p>
<dl class="section note"><dt>Note</dt><dd>In RTU mode 11 bits are used for each data byte. The coding system is 8bit binary.<ul>
<li>1 start bit.</li>
<li>8 data bits with LSB sent first.</li>
<li>1 bit for parity (Even, Odd)</li>
<li>1 or 2 stop bits (Two stopbits if no parity is used).</li>
</ul>
</dd></dl>
<p>In ASCII mode 10 bits are used. The coding system uses the hexadecimal ASCII characters 0-8 and A-F. One hexadecimal characters contains 4-bits of data.</p><ul>
<li>1 start bit</li>
<li>7 data bits with LSB sent first.</li>
<li>1 bit for parity (Even, Odd)</li>
<li>1 or 2 stop bits (Two stopbits if no parity is used).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pxHdl</td><td>A pointer to a MODBUS handle. If the function returns MB_ENOERR the handle is updated to hold a new and valid master handle. This handle should never be modified by the user. </td></tr>
    <tr><td class="paramname">eMode</td><td>The serial transmission mode to use. Either MB_RTU or MB_ASCII. </td></tr>
    <tr><td class="paramname">ucPort</td><td>The serial port to use. The meaning of this value depends on the porting layer. </td></tr>
    <tr><td class="paramname">ulBaudRate</td><td>The baudrate. For example 38400. </td></tr>
    <tr><td class="paramname">eParity</td><td>The parity to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if a new MASTER instances is ready. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AVR-ATMEGA_ATMELSTUDIO_BARE_2demo_8c-example.html#a2">AVR-ATMEGA_ATMELSTUDIO_BARE/demo.c</a>.</dd>
</dl>

</div>
</div>
<a id="gac74f170aa8f7e71cb0ca0e0f32cb5a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac74f170aa8f7e71cb0ca0e0f32cb5a02">&#9670;&nbsp;</a></span>eMBMSerialInitExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMSerialInitExt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> *&#160;</td>
          <td class="paramname"><em>pxHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga7a4a53c89f13d601f2830fea508e2307">eMBSerialMode</a>&#160;</td>
          <td class="paramname"><em>eMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#gaf632da489ebc3708ec3ab6791ee53fa4">ULONG</a>&#160;</td>
          <td class="paramname"><em>ulBaudRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#gab7daf28bb4d8c43df08704d918323d42">eMBSerialParity</a>&#160;</td>
          <td class="paramname"><em>eParity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucStopBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instances for a serial MODBUS master instance using either ASCII or RTU transmission mode. </p>
<p>Identical to eMBMSerialInit with the exception that the number of stopbits can be set. Note that this can result in non standard conforming behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pxHdl</td><td>A pointer to a MODBUS handle. If the function returns MB_ENOERR the handle is updated to hold a new and valid master handle. This handle should never be modified by the user. </td></tr>
    <tr><td class="paramname">eMode</td><td>The serial transmission mode to use. Either MB_RTU or MB_ASCII. </td></tr>
    <tr><td class="paramname">ucPort</td><td>The serial port to use. The meaning of this value depends on the porting layer. </td></tr>
    <tr><td class="paramname">ulBaudRate</td><td>The baudrate. For example 38400. </td></tr>
    <tr><td class="paramname">eParity</td><td>The parity to use. </td></tr>
    <tr><td class="paramname">ucStopBits</td><td>Number of stopbits to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if a new MASTER instances is ready. </dd></dl>

</div>
</div>
<a id="gaa9c3b86a71907fe1450dc1652e5ab9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9c3b86a71907fe1450dc1652e5ab9cc">&#9670;&nbsp;</a></span>eMBMSetSlaveTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMSetSlaveTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usNMilliSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the slave timeout for the next request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">usNMilliSeconds</td><td>The new slave device timeout. If no response is received within this time window after a MODBUS request has been sent to the slave the API functions will return eMBErrorCode::MB_ETIMEDOUT to indicate an timeout error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the new slave timeout will be used on the next request. </dd></dl>

</div>
</div>
<a id="ga8bb69ce870efbcebcae69d62bc7ec93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bb69ce870efbcebcae69d62bc7ec93e">&#9670;&nbsp;</a></span>eMBMTCPConnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMTCPConnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mb__port.html#gaebb9e13210d88d43e32e735ada43a425">CHAR</a> *&#160;</td>
          <td class="paramname"><em>pcTCPClientAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usTCPPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to a new MODBUS TCP slave. </p>
<p>If a connection is already open the old connection is closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">pcTCPClientAddress</td><td>A TCP client address. This address is directly passed to the porting layer and therefore its meaning is platform dependent. </td></tr>
    <tr><td class="paramname">usTCPPort</td><td>The TCP port to use. 502 is standard. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if a connection has been opened. In case of a connection error eMBErrorCode::MB_EIO. </dd></dl>

</div>
</div>
<a id="gad6f5c0ada100b309ba32c06ef646da8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6f5c0ada100b309ba32c06ef646da8c">&#9670;&nbsp;</a></span>eMBMTCPDisconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMTCPDisconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnects a MODBUS TCP slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ed45e6af7c0078901bc460b136f82cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ed45e6af7c0078901bc460b136f82cc">&#9670;&nbsp;</a></span>eMBMTCPInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMTCPInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> *&#160;</td>
          <td class="paramname"><em>pxHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instaces for a MODBUS TCP master. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pxHdl</td><td>A pointer to a MODBUS handle. If the function returns MB_ENOERR the handle is updated to hold a new and valid master handle. This handle should never be modified by the user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if a new MASTER instances is ready. </dd></dl>

</div>
</div>
<a id="ga8d07d81e5f395979314919d2634af520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d07d81e5f395979314919d2634af520">&#9670;&nbsp;</a></span>eMBMUDPInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMUDPInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a> *&#160;</td>
          <td class="paramname"><em>pxHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mb__port.html#gaebb9e13210d88d43e32e735ada43a425">CHAR</a> *&#160;</td>
          <td class="paramname"><em>pcUDPBindAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga2a3e0cda5f1249bef6db47c5eb8e3813">LONG</a>&#160;</td>
          <td class="paramname"><em>uUDPListenPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instaces for a MODBUS UDP master. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pxHdl</td><td>A pointer to a MODBUS handle. If the function returns MB_ENOERR the handle is updated to hold a new and valid master handle. This handle should never be modified by the user. </td></tr>
    <tr><td class="paramname">pcUDPBindAddress</td><td>Not used within the stack but passed to the porting layer. This argument can be used to bind only to a specific IP address. </td></tr>
    <tr><td class="paramname">uUDPListenPort</td><td>Use -1 if the listing port should be allocated dynamically by the porting layer. Otherwise pass a valid port number between 0 and 65535. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if a new MASTER instances is ready. </dd></dl>

</div>
</div>
<a id="gaafab766276af3a117f7b1969f3081158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafab766276af3a117f7b1969f3081158">&#9670;&nbsp;</a></span>eMBMUDPSetSlave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMUDPSetSlave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mb__port.html#gaebb9e13210d88d43e32e735ada43a425">CHAR</a> *&#160;</td>
          <td class="paramname"><em>pcUDPClientAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usUDPSlavePort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the IP address of the MODBUS UDP slave. </p>
<p>Not data is actually sent by specifying the client address. All future data sent by any of the read/write registers calls will be directed to this client address. The previous client address is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">pcUDPClientAddress</td><td>A UDP client address. This address is directly passed to the porting layer and therefore its meaning is platform dependent. </td></tr>
    <tr><td class="paramname">usUDPSlavePort</td><td>The UDP port to use. 502 is standard. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if a connection has been opened. In case of a connection error eMBErrorCode::MB_EIO.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A reference to pcUDPClientAddress is stored internally. As long as this instance is used the data where pcUDPClientAddress points to must not change. This specially implies that extra care has to be taken when the address is stored on the stack. </dd></dl>

</div>
</div>
<a id="gaeeceb2922f58c0df0a53d38885305715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeceb2922f58c0df0a53d38885305715">&#9670;&nbsp;</a></span>eMBMWriteCoils()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMWriteCoils </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usCoilStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usNCoils</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>arubCoilsIn</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Write Coils</em> from a slave using the MODBUS function code <b>0x0F</b> </p>
<p>The coils are packed as one coil per bit. Statis is 1=ON and 0=OFF. The LSB of the first data byte contains the coil addressed in the query. The other coils follow toward the high order of the byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">usCoilStartAddress</td><td>Address of first coil. </td></tr>
    <tr><td class="paramname">usNCoils</td><td>Number of coils to read. </td></tr>
    <tr><td class="paramname">arubCoilsIn</td><td>An array with a size of at least usNCoils/8 bytes. The size must be rounded up to next integer. A </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the slave responded within the timeout and the the reply conforms to the MODBUS protocol specification. In this case the array arubBufferIn contains the values returned by the slave. In case of an exception from the slave any of the MODBUS exceptions can be returned. If the slave did not respond within the timeout the function returns eMBErrorCode::MB_ETIMEDOUT. </dd></dl>

</div>
</div>
<a id="ga19014cb4fe74a3f10ad344755d0441ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19014cb4fe74a3f10ad344755d0441ec">&#9670;&nbsp;</a></span>eMBMWriteFileRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMWriteFileRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structxMBMFileSubWriteReq__t.html">xMBMFileSubWriteReq_t</a>&#160;</td>
          <td class="paramname"><em>arxSubRequests</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usNSubRequests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>)Write File Record</em> to a MODBUS slave with function code <b>0x15</b> </p>
<p>This function issues a write file record request. The caller of this function is required to provide an array of arxSubRequests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">arxSubRequests</td><td>Sub requests for file records. </td></tr>
    <tr><td class="paramname">usNSubRequests</td><td>Size of the arxSubRequests arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the write file record command was successfull. If the arguments are not valid, e.g the number of sub requests would exceed the maximum length of a MODBUS frame, the function returns eMBErrorCode::MB_EINVAL. In case of an exception returned by the slave any of the MODBUS exceptions can be returned. If the slave did not respond within the timeout the function returns eMBErrorCode::MB_ETIMEDOUT. </dd></dl>

</div>
</div>
<a id="ga1e0d9166403d5170e0de3fc365b6deff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e0d9166403d5170e0de3fc365b6deff">&#9670;&nbsp;</a></span>eMBMWriteMultipleRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMWriteMultipleRegisters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usRegStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubNRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>arusBufferIn</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Write Multiple Registers</em> from a slave using the MODBUS function code <b>0x10</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">usRegStartAddress</td><td>First register to write to. </td></tr>
    <tr><td class="paramname">ubNRegs</td><td>Number of registers to write. </td></tr>
    <tr><td class="paramname">arusBufferIn</td><td>An Array of USHORT values of at least ubNRegs elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the slave responded within the timeout and the the reply conforms to the MODBUS protocol specification. In this case the array arusBufferOut contains the values returned by the slave. In case of an exception from the slave any of the MODBUS exceptions can be returned. If the slave did not respond within the timeout the function returns eMBErrorCode::MB_ETIMEDOUT. Any other errors are IO errors. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AVR-ATMEGA_ATMELSTUDIO_BARE_2demo_8c-example.html#a6">AVR-ATMEGA_ATMELSTUDIO_BARE/demo.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga4441839f7b7f48e8ce0e357db87daa29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4441839f7b7f48e8ce0e357db87daa29">&#9670;&nbsp;</a></span>eMBMWriteSingleCoil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMWriteSingleCoil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usOutputAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#gaf492d2bddcb2befacb3aa03dcdf9aafd">BOOL</a>&#160;</td>
          <td class="paramname"><em>bOn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Write Coil</em> on slave using the MODBUS function code <b>0x05</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">usOutputAddress</td><td>Address of coil. </td></tr>
    <tr><td class="paramname">bOn</td><td>Either <code>TRUE</code> or <code>FALSE</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the slave responded within the timeout and the the reply conforms to the MODBUS protocol specification. In case of an exception from the slave any of the MODBUS exceptions can be returned. If the slave did not respond within the timeout the function returns eMBErrorCode::MB_ETIMEDOUT. </dd></dl>

</div>
</div>
<a id="gabdc2ddc7fda6022ccfda8b94eb2e5394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdc2ddc7fda6022ccfda8b94eb2e5394">&#9670;&nbsp;</a></span>eMBMWriteSingleRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBMWriteSingleRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usRegAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Write Single Register</em> in a slave using the MODBUS function code <b>0x06</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. Note that a broadcast address is not allowed for a function which expects a response. </td></tr>
    <tr><td class="paramname">usRegAddress</td><td>The register address to write. </td></tr>
    <tr><td class="paramname">usValue</td><td>The value which should be written to the register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the slave responded within the timeout and the the reply conforms to the MODBUS protocol specification. In this case the array arusBufferOut contains the values returned by the slave. In case of an exception from the slave any of the MODBUS exceptions can be returned. If the slave did not respond within the timeout the function returns eMBErrorCode::MB_ETIMEDOUT. Any other errors are IO errors. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AVR-ATMEGA_ATMELSTUDIO_BARE_2demo_8c-example.html#a4">AVR-ATMEGA_ATMELSTUDIO_BARE/demo.c</a>.</dd>
</dl>

</div>
</div>
<a id="gad2b1feaff5f800c554ac1701e11607ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2b1feaff5f800c554ac1701e11607ac">&#9670;&nbsp;</a></span>vMBMMaskWriteRegisterPolled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP void vMBMMaskWriteRegisterPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usRegAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usANDMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usORMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *&#160;</td>
          <td class="paramname"><em>peState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *&#160;</td>
          <td class="paramname"><em>peStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Mask Single Register</em> in a slave using the MODBUS function code <b>0x16</b>. </p>
<p>After a write to a register the content of the register is modified as following. New Content = (Current Content AND usANDMask) OR (usORMask AND (NOT usANDMask))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. Note that a broadcast address is not allowed for a function which expects a response. </td></tr>
    <tr><td class="paramname">usRegAddress</td><td>The register address to write. </td></tr>
    <tr><td class="paramname">usANDMask</td><td>AND mask </td></tr>
    <tr><td class="paramname">usORMask</td><td>OR mask </td></tr>
    <tr><td class="paramname">peState</td><td>A pointer where the internal state can be stored. This value should be initialized to MBM_STATE_NONE. Violating this rule results in undefined behavior. </td></tr>
    <tr><td class="paramname">peStatus</td><td>A pointer to a status variable. After the command has finished the status variable contains the final result of the transaction. The error codes are the same as for the blocking version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5aef2e1e004552811a4232d2afec61f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aef2e1e004552811a4232d2afec61f4">&#9670;&nbsp;</a></span>vMBMReadCoilsPolled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP void vMBMReadCoilsPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usCoilStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usNCoils</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>arubBufferOut</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *&#160;</td>
          <td class="paramname"><em>peState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *&#160;</td>
          <td class="paramname"><em>peStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Read Coils</em> from a slave using the MODBUS function code <b>0x01</b> </p>
<p>The coils are packed as one coil per bit. Statis is 1=ON and 0=OFF. The LSB of the first data byte contains the coil addressed in the query. The other coils follow toward the high order of the byte. If the input quantity is not a multiple of eight the final data byte is padded with zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">usCoilStartAddress</td><td>Address of first coil. </td></tr>
    <tr><td class="paramname">usNCoils</td><td>Number of coils to read. </td></tr>
    <tr><td class="paramname">arubBufferOut</td><td>An array with a size of at least udNInputs/8 bytes. The size must be rounded up to next integer. </td></tr>
    <tr><td class="paramname">peState</td><td>A pointer where the internal state can be stored. This value should be initialized to MBM_STATE_NONE. Violating this rule results in undefined behavior. </td></tr>
    <tr><td class="paramname">peStatus</td><td>A pointer to a status variable. After the command has finished the status variable contains the final result of the transaction. The error codes are the same as for the blocking version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga65d6f42f061c62aa8da37d6110396feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65d6f42f061c62aa8da37d6110396feb">&#9670;&nbsp;</a></span>vMBMReadDiscreteInputsPolled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP void vMBMReadDiscreteInputsPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usInputStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usNInputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>arubBufferOut</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *&#160;</td>
          <td class="paramname"><em>peState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *&#160;</td>
          <td class="paramname"><em>peStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Read Discrete Inputs</em> from a slave using the MODBUS function code <b>0x02</b> </p>
<p>The discrete inputs are packed as one input per bit. Statis is 1=ON and 0=OFF. The LSB of the first data byte contains the input addressed in the query. The other inputs follow toward the high order of the byte. If the input quantity is not a multiple of eight the final data byte is padded with zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">usInputStartAddress</td><td>Address of first discrete input. </td></tr>
    <tr><td class="paramname">usNInputs</td><td>Number of discrete inputs to read. </td></tr>
    <tr><td class="paramname">arubBufferOut</td><td>An array with a size of at least udNInputs/8 bytes. The size must be rounded up to next integer. </td></tr>
    <tr><td class="paramname">peState</td><td>A pointer where the internal state can be stored. This value should be initialized to MBM_STATE_NONE. Violating this rule results in undefined behavior. </td></tr>
    <tr><td class="paramname">peStatus</td><td>A pointer to a status variable. After the command has finished the status variable contains the final result of the transaction. The error codes are the same as for the blocking version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga610ec05392e913a2088c577718e5da89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga610ec05392e913a2088c577718e5da89">&#9670;&nbsp;</a></span>vMBMReadFileRecordPolled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP void vMBMReadFileRecordPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structxMBMFileSubReadReq__t.html">xMBMFileSubReadReq_t</a>&#160;</td>
          <td class="paramname"><em>arxSubRequests</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structxMBMFileSubReadResp__t.html">xMBMFileSubReadResp_t</a>&#160;</td>
          <td class="paramname"><em>arxSubResponses</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usNSubRequests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *&#160;</td>
          <td class="paramname"><em>peState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *&#160;</td>
          <td class="paramname"><em>peStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>)Read File Record</em> from a MODBUS slave with function code <b>0x14</b> </p>
<p>This function issues a read file record request. The caller of this function is required to provide an (possibly unitialized) array of arxSubResponses. The size of this array must be equal or larger than the number of sub requests within arxSubRequests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">arxSubRequests</td><td>Sub requests for file records. </td></tr>
    <tr><td class="paramname">arxSubResponses</td><td>A sub response for every requested arxSubRequests. </td></tr>
    <tr><td class="paramname">usNSubRequests</td><td>Size of the arxSubRequests arrays. </td></tr>
    <tr><td class="paramname">peState</td><td>A pointer where the internal state can be stored. This value should be initialized to MBM_STATE_NONE. Violating this rule results in undefined behavior. </td></tr>
    <tr><td class="paramname">peStatus</td><td>A pointer to a status variable. After the command has finished the status variable contains the final result of the transaction. The error codes are the same as for the blocking version eMBMReadFileRecord. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3658094a1c51a51ac5bdb1972974b62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3658094a1c51a51ac5bdb1972974b62e">&#9670;&nbsp;</a></span>vMBMReadHoldingRegistersPolled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP void vMBMReadHoldingRegistersPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usRegStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubNRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>arusBufferOut</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *&#160;</td>
          <td class="paramname"><em>peState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *&#160;</td>
          <td class="paramname"><em>peStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Read Holding Registers</em> from a slave using the MODBUS function code <b>0x03</b> with the Non-Blocking API. </p>
<p>This function provides the same functionality as the function eMBMReadHoldingRegisters but uses a different interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. Note that a broadcast address is not allowed for a function which expects a response. </td></tr>
    <tr><td class="paramname">usRegStartAddress</td><td>The first holding register to be read. We use protocol addresses starting at zero. </td></tr>
    <tr><td class="paramname">ubNRegs</td><td>Number of registers to read. </td></tr>
    <tr><td class="paramname">arusBufferOut</td><td>An array of USHORT values of at least ubNRegs elements. </td></tr>
    <tr><td class="paramname">peState</td><td>A pointer where the internal state can be stored. This value should be initialized to MBM_STATE_NONE. Violating this rule results in undefined behavior. </td></tr>
    <tr><td class="paramname">peStatus</td><td>A pointer to a status variable. After the command has finished the status variable contains the final result of the transaction. The error codes are the same as for the blocking version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga64900771ca6c95c57df5e6a7040da202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64900771ca6c95c57df5e6a7040da202">&#9670;&nbsp;</a></span>vMBMReadInputRegistersPolled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP void vMBMReadInputRegistersPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usRegStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubNRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>arusBufferOut</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *&#160;</td>
          <td class="paramname"><em>peState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *&#160;</td>
          <td class="paramname"><em>peStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Read Input Registers</em> from a slave using the MODBUS function code <b>0x04</b> with the Non-Blocking API. </p>
<p>This function provides the same functionality as the function eMBMReadInputRegisters but uses a different interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. Note that a broadcast address is not allowed. </td></tr>
    <tr><td class="paramname">usRegStartAddress</td><td>The first holding register to be read starting at zero. </td></tr>
    <tr><td class="paramname">ubNRegs</td><td>Number of registers to read. </td></tr>
    <tr><td class="paramname">arusBufferOut</td><td>An array of USHORT values of at least ubNRegs elements. </td></tr>
    <tr><td class="paramname">peState</td><td>A pointer where the internal state can be stored. This value should be initialized to MBM_STATE_NONE. Violating this rule results in undefined behavior. </td></tr>
    <tr><td class="paramname">peStatus</td><td>A pointer to a status variable. After the command has finished the status variable contains the final result of the transaction. The error codes are the same as for the blocking version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaacad64422c656aaacfdff4bf8486a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaacad64422c656aaacfdff4bf8486a6f">&#9670;&nbsp;</a></span>vMBMReadWriteMultipleRegistersPolled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP void vMBMReadWriteMultipleRegistersPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usWriteRegStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubWriteNRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>arusBufferIn</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usReadRegStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubReadNRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>arusBufferOut</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *&#160;</td>
          <td class="paramname"><em>peState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *&#160;</td>
          <td class="paramname"><em>peStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Read/Write Multiple Registers</em> from a slave using the MODBUS function code <b>0x17</b> </p>
<dl class="section note"><dt>Note</dt><dd>The pointers arusBufferIn and arusBufferOut can point to the same memory location. In this case the old contents is overwritten with the returned registers values.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">usWriteRegStartAddress</td><td>First register to write on the slave. </td></tr>
    <tr><td class="paramname">ubWriteNRegs</td><td>Number of registers to write. </td></tr>
    <tr><td class="paramname">arusBufferIn</td><td>An Array of USHORT values of ubWriteNRegs elements which should be written on the slave. </td></tr>
    <tr><td class="paramname">usReadRegStartAddress</td><td>First register to read from the slave. </td></tr>
    <tr><td class="paramname">ubReadNRegs</td><td>Number of registers to read. </td></tr>
    <tr><td class="paramname">arusBufferOut</td><td>An Array of ubReadNRegs elements where the registers values returned by the slave should be stored. </td></tr>
    <tr><td class="paramname">peState</td><td>A pointer where the internal state can be stored. This value should be initialized to MBM_STATE_NONE. Violating this rule results in undefined behavior. </td></tr>
    <tr><td class="paramname">peStatus</td><td>A pointer to a status variable. After the command has finished the status variable contains the final result of the transaction. The error codes are the same as for the blocking version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaea745bf7819e92758d156c8167459904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea745bf7819e92758d156c8167459904">&#9670;&nbsp;</a></span>vMBMReadWriteRAWPDUPolled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP void vMBMReadWriteRAWPDUPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucFunctionCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>arubPayloadIn</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubPayloadInLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>arubPayloadOut</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubPayloadOutLengthMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> *&#160;</td>
          <td class="paramname"><em>pubPayloadOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *&#160;</td>
          <td class="paramname"><em>peState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *&#160;</td>
          <td class="paramname"><em>peStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function for sending raw MODBUS PDUs to a MODBUS slave. This function can be used if you want to transport custom data over a MODBUS connection or for briding other protocols. Please note that of course most standard slaves won't know how to deal with these custom data payload and therefore its use should be limited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">ucFunctionCode</td><td>MODBUS function code used for transport. Must be between 1 and 127. Recommend values are between 65-72 and 100-110. </td></tr>
    <tr><td class="paramname">arubPayloadIn</td><td>MODBUS request which will be sent to the slave. </td></tr>
    <tr><td class="paramname">ubPayloadInLength</td><td>Length of MODBUS request. Maximum is 252 bytes. </td></tr>
    <tr><td class="paramname">arubPayloadOut</td><td>Holds the MODBUS response sent by the slave. arubPayloadOut can be <code>NULL</code> is ubPayloadOutLengthMax is set to zero. </td></tr>
    <tr><td class="paramname">ubPayloadOutLengthMax</td><td>Size of the buffer arubPayloadOut in bytes. If the slave response exceeds the number of bytes available in the buffer the function set peStatus to eMBErrorCode::MB_EINVAL. </td></tr>
    <tr><td class="paramname">pubPayloadOutLength</td><td>Actual number of bytes returned by the slave. </td></tr>
    <tr><td class="paramname">peState</td><td>A pointer where the internal state can be stored. This value should be initialized to MBM_STATE_NONE. Violating this rule results in undefined behavior. </td></tr>
    <tr><td class="paramname">peStatus</td><td>A pointer to a status variable. After the command has finished the status variable contains the final result of the transaction. The error codes are the same as for the blocking version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga498439f80cf54f3f6c0e682f13b910e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga498439f80cf54f3f6c0e682f13b910e9">&#9670;&nbsp;</a></span>vMBMReportSlaveID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP void vMBMReportSlaveID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>arubBufferOut</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubBufferMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> *&#160;</td>
          <td class="paramname"><em>pubLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *&#160;</td>
          <td class="paramname"><em>peState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *&#160;</td>
          <td class="paramname"><em>peStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Report slave ID</em> from a MODBUS slave with function code <b>0x11</b> </p>
<p>This function issues the report slave id command to a MODBUS slave. The response is then stored in the buffer provided by arubBufferOut where the caller has to allocate sufficient space. The maximum amount of space available is determined by ubBufferMax. If there is not enough space available the function returns eMBErrorCode::MB_ENORES.</p>
<p>There is no chance for the MODBUS stack to tell something about the content since the content is vendor specific.</p>
<dl class="section note"><dt>Note</dt><dd>There are some non vendor specific fields but most vendors do not implement them correctly. Therefore we have completely avoided interpreting the data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">arubBufferOut</td><td>Buffer which can hold ubBufferMax bytes. </td></tr>
    <tr><td class="paramname">ubBufferMax</td><td>Size of buffer. </td></tr>
    <tr><td class="paramname">pubLength</td><td>If the call succeeds contains the number of bytes written to the buffer. </td></tr>
    <tr><td class="paramname">peState</td><td>A pointer where the internal state can be stored. This value should be initialized to MBM_STATE_NONE. Violating this rule results in undefined behavior. </td></tr>
    <tr><td class="paramname">peStatus</td><td>A pointer to a status variable. After the command has finished the status variable contains the final result of the transaction. The error codes are the same as for the blocking version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3a3ad933943a25e382fcca41714c3f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a3ad933943a25e382fcca41714c3f01">&#9670;&nbsp;</a></span>vMBMWriteCoilsPolled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP void vMBMWriteCoilsPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usCoilStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usNCoils</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>arubCoilsIn</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *&#160;</td>
          <td class="paramname"><em>peState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *&#160;</td>
          <td class="paramname"><em>peStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Write Coils</em> from a slave using the MODBUS function code <b>0x0F</b> </p>
<p>The coils are packed as one coil per bit. Statis is 1=ON and 0=OFF. The LSB of the first data byte contains the coil addressed in the query. The other coils follow toward the high order of the byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">usCoilStartAddress</td><td>Address of first coil. </td></tr>
    <tr><td class="paramname">usNCoils</td><td>Number of coils to read. </td></tr>
    <tr><td class="paramname">arubCoilsIn</td><td>An array with a size of at least usNCoils/8 bytes. The size must be rounded up to next integer. A </td></tr>
    <tr><td class="paramname">peState</td><td>A pointer where the internal state can be stored. This value should be initialized to MBM_STATE_NONE. Violating this rule results in undefined behavior. </td></tr>
    <tr><td class="paramname">peStatus</td><td>A pointer to a status variable. After the command has finished the status variable contains the final result of the transaction. The error codes are the same as for the blocking version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga33a8c0c949f81237ac0bcac9a5d9a6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33a8c0c949f81237ac0bcac9a5d9a6ae">&#9670;&nbsp;</a></span>vMBMWriteFileRecordPolled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP void vMBMWriteFileRecordPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structxMBMFileSubWriteReq__t.html">xMBMFileSubWriteReq_t</a>&#160;</td>
          <td class="paramname"><em>arxSubRequests</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usNSubRequests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *&#160;</td>
          <td class="paramname"><em>peState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *&#160;</td>
          <td class="paramname"><em>peStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>)Write File Record</em> to a MODBUS slave with function code <b>0x15</b> </p>
<p>This function issues a write file record request. The caller of this function is required to provide an array of arxSubRequests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">arxSubRequests</td><td>Sub requests for file records. </td></tr>
    <tr><td class="paramname">usNSubRequests</td><td>Size of the arxSubRequests arrays. </td></tr>
    <tr><td class="paramname">peState</td><td>A pointer where the internal state can be stored. This value should be initialized to MBM_STATE_NONE. Violating this rule results in undefined behavior. </td></tr>
    <tr><td class="paramname">peStatus</td><td>A pointer to a status variable. After the command has finished the status variable contains the final result of the transaction. The error codes are the same as for the blocking version eMBMWriteFileRecord. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga02d5f48ea8d2fa5b2290572098dd6d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02d5f48ea8d2fa5b2290572098dd6d40">&#9670;&nbsp;</a></span>vMBMWriteMultipleRegistersPolled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP void vMBMWriteMultipleRegistersPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usRegStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a>&#160;</td>
          <td class="paramname"><em>ubNRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>arusBufferIn</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *&#160;</td>
          <td class="paramname"><em>peState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *&#160;</td>
          <td class="paramname"><em>peStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Write Multiple Registers</em> from a slave using the MODBUS function code <b>0x10</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">usRegStartAddress</td><td>First register to write to. </td></tr>
    <tr><td class="paramname">ubNRegs</td><td>Number of registers to write. </td></tr>
    <tr><td class="paramname">arusBufferIn</td><td>An Array of USHORT values of at least ubNRegs elements. </td></tr>
    <tr><td class="paramname">peState</td><td>A pointer where the internal state can be stored. This value should be initialized to MBM_STATE_NONE. Violating this rule results in undefined behavior. </td></tr>
    <tr><td class="paramname">peStatus</td><td>A pointer to a status variable. After the command has finished the status variable contains the final result of the transaction. The error codes are the same as for the blocking version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga292993bce43830d6f75a535c7d6fd476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga292993bce43830d6f75a535c7d6fd476">&#9670;&nbsp;</a></span>vMBMWriteSingleCoilPolled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP void vMBMWriteSingleCoilPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usOutputAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#gaf492d2bddcb2befacb3aa03dcdf9aafd">BOOL</a>&#160;</td>
          <td class="paramname"><em>bOn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *&#160;</td>
          <td class="paramname"><em>peState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *&#160;</td>
          <td class="paramname"><em>peStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Write Coil</em> on slave using the MODBUS function code <b>0x06</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. </td></tr>
    <tr><td class="paramname">usOutputAddress</td><td>Address of coil. </td></tr>
    <tr><td class="paramname">bOn</td><td>Either <code>TRUE</code> or <code>FALSE</code>. </td></tr>
    <tr><td class="paramname">peState</td><td>A pointer where the internal state can be stored. This value should be initialized to MBM_STATE_NONE. Violating this rule results in undefined behavior. </td></tr>
    <tr><td class="paramname">peStatus</td><td>A pointer to a status variable. After the command has finished the status variable contains the final result of the transaction. The error codes are the same as for the blocking version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9ae6bcc86348b59e12fdfa41738b3221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ae6bcc86348b59e12fdfa41738b3221">&#9670;&nbsp;</a></span>vMBMWriteSingleRegisterPolled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_DLLEXP void vMBMWriteSingleRegisterPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mbm.html#ga39ff7ecabacfd2155328f82045368d74">xMBMHandle</a>&#160;</td>
          <td class="paramname"><em>xHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga4f4bb67531a9bf6f0b9c6ad76aeba587">UCHAR</a>&#160;</td>
          <td class="paramname"><em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usRegAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mbm.html#gaca22d8b649564e798570df743ed2b044">eMBMQueryState</a> *&#160;</td>
          <td class="paramname"><em>peState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> *&#160;</td>
          <td class="paramname"><em>peStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Write Single Register</em> in a slave using the MODBUS function code <b>0x06</b> with the Non-Blocking API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHdl</td><td>A valid MODBUS master handle. </td></tr>
    <tr><td class="paramname">ucSlaveAddress</td><td>Slave address. Note that a broadcast address is not allowed for a function which expects a response. </td></tr>
    <tr><td class="paramname">usRegAddress</td><td>The register address to write. </td></tr>
    <tr><td class="paramname">usValue</td><td>The value which should be written to the register. </td></tr>
    <tr><td class="paramname">peState</td><td>A pointer where the internal state can be stored. This value should be initialized to MBM_STATE_NONE. Violating this rule results in undefined behavior. </td></tr>
    <tr><td class="paramname">peStatus</td><td>A pointer to a status variable. After the command has finished the status variable contains the final result of the transaction. The error codes are the same as for the blocking version. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
