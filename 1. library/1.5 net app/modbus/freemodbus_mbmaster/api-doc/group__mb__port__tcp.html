<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EE MODBUS MASTER: MODBUS Porting Layer (TCP)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="dox.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EE MODBUS MASTER
   &#160;<span id="projectnumber">v2022 (2022-12-23)</span>
   </div>
   <div id="projectbrief">portable C/C++ MODBUS stack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__mb__port__tcp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MODBUS Porting Layer (TCP)<div class="ingroups"><a class="el" href="group__mb__port.html">MODBUS Porting Layer</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0ea68fd7294bc438d3fb9f22a16871d6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mb__port__tcp.html#ga0ea68fd7294bc438d3fb9f22a16871d6">peMBPTCPClientConnectedCB</a>) (<a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xMBHdl, xMBPTCPClientHandle xTCPClientHdl) MB_CDECL_SUFFIX</td></tr>
<tr class="separator:ga0ea68fd7294bc438d3fb9f22a16871d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga854f087065971cec8f7c8e918abee12e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mb__port__tcp.html#ga854f087065971cec8f7c8e918abee12e">peMBPTCPClientNewDataCB</a>) (<a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xMBHdl, xMBPTCPClientHandle xTCPClientHdl) MB_CDECL_SUFFIX</td></tr>
<tr class="separator:ga854f087065971cec8f7c8e918abee12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga618c86567dee4ed1ad96c57497fd5960"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mb__port__tcp.html#ga618c86567dee4ed1ad96c57497fd5960">peMBPTCPClientDisconnectedCB</a>) (<a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xMBHdl, xMBPTCPClientHandle xTCPClientHdl) MB_CDECL_SUFFIX</td></tr>
<tr class="separator:ga618c86567dee4ed1ad96c57497fd5960"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga22ebde6b78195fb6a9443d8681fd5cb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mb__port__tcp.html#ga22ebde6b78195fb6a9443d8681fd5cb0">eMBPTCPClientInit</a> (xMBPTCPHandle *pxTCPHdl, <a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xMBHdl, <a class="el" href="group__mb__port__tcp.html#ga854f087065971cec8f7c8e918abee12e">peMBPTCPClientNewDataCB</a> eMBPTCPClientNewDATAFN, <a class="el" href="group__mb__port__tcp.html#ga618c86567dee4ed1ad96c57497fd5960">peMBPTCPClientDisconnectedCB</a> eMBPTCPClientDisconnectedFN)</td></tr>
<tr class="separator:ga22ebde6b78195fb6a9443d8681fd5cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e97a0e1017b7d09b3e2dd5b5971480b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mb__port__tcp.html#ga6e97a0e1017b7d09b3e2dd5b5971480b">eMBPTCPClientClose</a> (xMBPTCPHandle xTCPHdl)</td></tr>
<tr class="separator:ga6e97a0e1017b7d09b3e2dd5b5971480b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cc368d988efd7878dc951296595d6a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mb__port__tcp.html#ga8cc368d988efd7878dc951296595d6a4">eMBPTCPClientOpen</a> (xMBPTCPHandle xTCPHdl, xMBPTCPClientHandle *pxTCPClientHdl, const <a class="el" href="group__mb__port.html#gaebb9e13210d88d43e32e735ada43a425">CHAR</a> *pcConnectAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usTCPPort)</td></tr>
<tr class="separator:ga8cc368d988efd7878dc951296595d6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff7aa9cf13d8bc92ca7ea60cadafcaf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mb__port__tcp.html#gaff7aa9cf13d8bc92ca7ea60cadafcaf7">eMBPTCPServerInit</a> (xMBPTCPHandle *pxTCPHdl, <a class="el" href="group__mb__port.html#gaebb9e13210d88d43e32e735ada43a425">CHAR</a> *pcBindAddress, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usTCPPort, <a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xMBHdl, <a class="el" href="group__mb__port__tcp.html#ga854f087065971cec8f7c8e918abee12e">peMBPTCPClientNewDataCB</a> eMBPTCPClientNewDataFN, <a class="el" href="group__mb__port__tcp.html#ga618c86567dee4ed1ad96c57497fd5960">peMBPTCPClientDisconnectedCB</a> eMBPTCPClientDisconnectedFN, <a class="el" href="group__mb__port__tcp.html#ga0ea68fd7294bc438d3fb9f22a16871d6">peMBPTCPClientConnectedCB</a> eMBPTCPClientConnectedFN)</td></tr>
<tr class="separator:gaff7aa9cf13d8bc92ca7ea60cadafcaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacda6ffb210a2e61b5552a54ca21d33ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mb__port__tcp.html#gacda6ffb210a2e61b5552a54ca21d33ed">eMBTCPServerClose</a> (xMBPTCPHandle xTCPHdl)</td></tr>
<tr class="separator:gacda6ffb210a2e61b5552a54ca21d33ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db4c27a235f6c6bb618bca2ceaadb08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mb__port__tcp.html#ga9db4c27a235f6c6bb618bca2ceaadb08">eMBPTCPConRead</a> (xMBPTCPHandle xTCPHdl, xMBPTCPClientHandle xTCPClientHdl, <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> *pubBuffer, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> *pusBufferLen, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usBufferMax)</td></tr>
<tr class="separator:ga9db4c27a235f6c6bb618bca2ceaadb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63dbe1e14d621166915c84e6a0515f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mb__port__tcp.html#ga63dbe1e14d621166915c84e6a0515f20">eMBPTCPConWrite</a> (xMBPTCPHandle xTCPHdl, xMBPTCPClientHandle xTCPClientHdl, const <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> *pubBuffer, <a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> usBufferLen)</td></tr>
<tr class="separator:ga63dbe1e14d621166915c84e6a0515f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1de32d274d6ee531bed62fca7e2721db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mb__port__tcp.html#ga1de32d274d6ee531bed62fca7e2721db">eMBPTCPConClose</a> (xMBPTCPHandle xTCPHdl, xMBPTCPClientHandle xTCPClientHdl)</td></tr>
<tr class="separator:ga1de32d274d6ee531bed62fca7e2721db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga0ea68fd7294bc438d3fb9f22a16871d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ea68fd7294bc438d3fb9f22a16871d6">&#9670;&nbsp;</a></span>peMBPTCPClientConnectedCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>( * peMBPTCPClientConnectedCB) (<a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xMBHdl, xMBPTCPClientHandle xTCPClientHdl) MB_CDECL_SUFFIX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called by the TCP porting layer when a new client connection is made. </p>
<p>The stack will check if it can still handle more clients. This value is configured by the compile time configuration directive MBS_TCP_MAX_CLIENTS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xMBHdl</td><td>A handle to a MODBUS stack. </td></tr>
    <tr><td class="paramname">xTCPClientHdl</td><td>New client handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the stack has accepted this client. If no more clients can be handled the function returns eMBErrorCode::MB_ENORES. In this case the porting layer should drop the client connection. In case of an invalid handle this function returns eMBErrorCode::MB_EINVAL. </dd></dl>

</div>
</div>
<a id="ga618c86567dee4ed1ad96c57497fd5960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga618c86567dee4ed1ad96c57497fd5960">&#9670;&nbsp;</a></span>peMBPTCPClientDisconnectedCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>( * peMBPTCPClientDisconnectedCB) (<a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xMBHdl, xMBPTCPClientHandle xTCPClientHdl) MB_CDECL_SUFFIX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by the porting layer when a client has disconnected. </p>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the stack was notified correctly that the client has been disconnected. eMBErrorCode::MB_EINVAL if the MODBUS handle or the client index was invalid. </dd></dl>

</div>
</div>
<a id="ga854f087065971cec8f7c8e918abee12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga854f087065971cec8f7c8e918abee12e">&#9670;&nbsp;</a></span>peMBPTCPClientNewDataCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>( * peMBPTCPClientNewDataCB) (<a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a> xMBHdl, xMBPTCPClientHandle xTCPClientHdl) MB_CDECL_SUFFIX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by the TCP porting layer when new data is available for a TCP client. </p>
<p>This function shall be called by the porting layer when new data is available. It is important that the actual state, i.e. the availability of data is used for calling this function and not the event of receiving some data on a connection. On BSD socket like implementations using select with FD_READ is a proper way to do it. In case the TCP/IP stack uses event based semantics the data should be buffered by the porting layer and the function should be called.</p>
<dl class="section note"><dt>Note</dt><dd>Please note that it is not guranteed that the stack is actually going to read the data when this function is called. For example this could happen if it is internally in a state for sending a response to another client. The porting layer should simply continuing calling this function with a small delay.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xMBHdl</td><td>A handle to a MODBUS stack. </td></tr>
    <tr><td class="paramname">xTCPClientHdl</td><td>A handle for a TCP client.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the data was handled. eMBErrorCode::MB_EINVAL if the MODBUS handle or the client index was invalid. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6e97a0e1017b7d09b3e2dd5b5971480b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e97a0e1017b7d09b3e2dd5b5971480b">&#9670;&nbsp;</a></span>eMBPTCPClientClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBPTCPClientClose </td>
          <td>(</td>
          <td class="paramtype">xMBPTCPHandle&#160;</td>
          <td class="paramname"><em>xTCPHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown a TCP instance for handling client connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTCPHdl</td><td>A TCP handle for a client instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MBErrorCode::MB_ENOERR if the client instances has been closed. </dd></dl>

</div>
</div>
<a id="ga22ebde6b78195fb6a9443d8681fd5cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22ebde6b78195fb6a9443d8681fd5cb0">&#9670;&nbsp;</a></span>eMBPTCPClientInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBPTCPClientInit </td>
          <td>(</td>
          <td class="paramtype">xMBPTCPHandle *&#160;</td>
          <td class="paramname"><em>pxTCPHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a>&#160;</td>
          <td class="paramname"><em>xMBHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port__tcp.html#ga854f087065971cec8f7c8e918abee12e">peMBPTCPClientNewDataCB</a>&#160;</td>
          <td class="paramname"><em>eMBPTCPClientNewDATAFN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port__tcp.html#ga618c86567dee4ed1ad96c57497fd5960">peMBPTCPClientDisconnectedCB</a>&#160;</td>
          <td class="paramname"><em>eMBPTCPClientDisconnectedFN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new TCP instance for handling client connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pxTCPHdl</td><td>A TCP handle for the client instance. </td></tr>
    <tr><td class="paramname">xMBHdl</td><td>A handle for the MODBUS stack. </td></tr>
    <tr><td class="paramname">eMBPTCPClientNewDATAFN</td><td>Callback function if new client data is available. </td></tr>
    <tr><td class="paramname">eMBPTCPClientDisconnectedFN</td><td>Callback function if a client connection is broken. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if a new instance has been crated. In case of invalid arguments it should return eMBErrorCode::MB_EINVAL. Otherweise eMBErrorCode::MB_EPORTERR. </dd></dl>

</div>
</div>
<a id="ga8cc368d988efd7878dc951296595d6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cc368d988efd7878dc951296595d6a4">&#9670;&nbsp;</a></span>eMBPTCPClientOpen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBPTCPClientOpen </td>
          <td>(</td>
          <td class="paramtype">xMBPTCPHandle&#160;</td>
          <td class="paramname"><em>xTCPHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xMBPTCPClientHandle *&#160;</td>
          <td class="paramname"><em>pxTCPClientHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mb__port.html#gaebb9e13210d88d43e32e735ada43a425">CHAR</a> *&#160;</td>
          <td class="paramname"><em>pcConnectAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usTCPPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a new client connection. </p>
<p>The client connection can be used to read and write data. If the stack wants to transmit data it calls the function eMBPTCPWrite. If new data is available the porting layer executes the callback function eMBPTCPClientNewDataCB. The stack can then read the data by a call to the function eMBPTCPRead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTCPHdl</td><td>A handle to the TCP client instance. </td></tr>
    <tr><td class="paramname">pxTCPClientHdl</td><td>If the function returns eMBErrorCode::MB_ENOERR this pointer holds a valid client handle. </td></tr>
    <tr><td class="paramname">pcConnectAddress</td><td>The IP address to connect to. </td></tr>
    <tr><td class="paramname">usTCPPort</td><td>The TCP port to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the connection has been opened and is ready for use. In case of a connection error eMBErrorCode::MB_EIO. All other errors are mapped to eMBErrorCode::MB_EPORTERR indicating that the WHOLE TCP client instance is faulty. </dd></dl>

</div>
</div>
<a id="ga1de32d274d6ee531bed62fca7e2721db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1de32d274d6ee531bed62fca7e2721db">&#9670;&nbsp;</a></span>eMBPTCPConClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBPTCPConClose </td>
          <td>(</td>
          <td class="paramtype">xMBPTCPHandle&#160;</td>
          <td class="paramname"><em>xTCPHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xMBPTCPClientHandle&#160;</td>
          <td class="paramname"><em>xTCPClientHdl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a TCP client connection. </p>
<p>Called by the stack when a TCP client connection should be closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTCPHdl</td><td>A handle to a TCP server instance. </td></tr>
    <tr><td class="paramname">xTCPClientHdl</td><td>A handle for a TCP client which should be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function should return eMBErrorCode::MB_ENOERR if the client connection has been closed. If any of the handles are invalid it should return eMBErrorCode::MB_EINVAL. All other errors should be mapped to eMBErrorCode::MB_EPORTERR. </dd></dl>

</div>
</div>
<a id="ga9db4c27a235f6c6bb618bca2ceaadb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9db4c27a235f6c6bb618bca2ceaadb08">&#9670;&nbsp;</a></span>eMBPTCPConRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBPTCPConRead </td>
          <td>(</td>
          <td class="paramtype">xMBPTCPHandle&#160;</td>
          <td class="paramname"><em>xTCPHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xMBPTCPClientHandle&#160;</td>
          <td class="paramname"><em>xTCPClientHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> *&#160;</td>
          <td class="paramname"><em>pubBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a> *&#160;</td>
          <td class="paramname"><em>pusBufferLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usBufferMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called by the MODBUS stack when new data should be read from a client. </p>
<p>This function must not block and should read up to <code>usBufferMax</code> bytes and store them into the buffer <code>pubBuffer</code>. The value of <code>pusBufferLen</code> should be set to the number of bytes read where 0 is used when there is no data available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTCPHdl</td><td>A handle to a TCP server instance. </td></tr>
    <tr><td class="paramname">xTCPClientHdl</td><td>A handle for a TCP client. </td></tr>
    <tr><td class="paramname">pubBuffer</td><td>A buffer of at least <code>usBufferMax</code> bytes where the read bytes from the client should be stored. </td></tr>
    <tr><td class="paramname">pusBufferLen</td><td>On return the value should hold the number of bytes written into the buffer. </td></tr>
    <tr><td class="paramname">usBufferMax</td><td>Maximum number of bytes which can be stored in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function should return eMBErrorCode::MB_ENOERR if zero or more bytes have been stored in the buffer and no error occurred. In case of a client error it should return eMBErrorCode::MB_EIO. In case of an invalid handle is should return eMBErrorCode::MB_EINVAL. Other errors should be mapped to eMBErrorCode::MB_EPORTERR signaling the stack that the porting layer is no longer functional. </dd></dl>

</div>
</div>
<a id="ga63dbe1e14d621166915c84e6a0515f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63dbe1e14d621166915c84e6a0515f20">&#9670;&nbsp;</a></span>eMBPTCPConWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBPTCPConWrite </td>
          <td>(</td>
          <td class="paramtype">xMBPTCPHandle&#160;</td>
          <td class="paramname"><em>xTCPHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xMBPTCPClientHandle&#160;</td>
          <td class="paramname"><em>xTCPClientHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mb__port.html#ga122c4acf389c050379f00341fdcd5812">UBYTE</a> *&#160;</td>
          <td class="paramname"><em>pubBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usBufferLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called by the MODBUS stack when new data should be sent over a client connection. </p>
<p>This function should not block and should transmit <code>usBufferLen</code> bytes over the client connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTCPHdl</td><td>A handle to a TCP server instance. </td></tr>
    <tr><td class="paramname">xTCPClientHdl</td><td>A handle for a TCP client. </td></tr>
    <tr><td class="paramname">pubBuffer</td><td>A buffer of <code>usBufferLen</code> bytes which should be transmitted. </td></tr>
    <tr><td class="paramname">usBufferLen</td><td>Number of bytes to transmit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function should return eMBErrorCode::MB_ENOERR if all bytes have been written. In case of an I/O error it should return eMBErrorCode::MB_EIO. In case of an invalid handle or invalid arguments it should return eMBErrorCode::MB_EINVAL. All other errors should be mapped to eMBErrorCode::MB_EPORTERR. </dd></dl>

</div>
</div>
<a id="gaff7aa9cf13d8bc92ca7ea60cadafcaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff7aa9cf13d8bc92ca7ea60cadafcaf7">&#9670;&nbsp;</a></span>eMBPTCPServerInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBPTCPServerInit </td>
          <td>(</td>
          <td class="paramtype">xMBPTCPHandle *&#160;</td>
          <td class="paramname"><em>pxTCPHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#gaebb9e13210d88d43e32e735ada43a425">CHAR</a> *&#160;</td>
          <td class="paramname"><em>pcBindAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port.html#ga5850d5316caf7f4cedd742fdf8cd7c02">USHORT</a>&#160;</td>
          <td class="paramname"><em>usTCPPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__cmn.html#ga7cf01cfe7c5e14a09ab4a16f65620ab2">xMBHandle</a>&#160;</td>
          <td class="paramname"><em>xMBHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port__tcp.html#ga854f087065971cec8f7c8e918abee12e">peMBPTCPClientNewDataCB</a>&#160;</td>
          <td class="paramname"><em>eMBPTCPClientNewDataFN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port__tcp.html#ga618c86567dee4ed1ad96c57497fd5960">peMBPTCPClientDisconnectedCB</a>&#160;</td>
          <td class="paramname"><em>eMBPTCPClientDisconnectedFN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mb__port__tcp.html#ga0ea68fd7294bc438d3fb9f22a16871d6">peMBPTCPClientConnectedCB</a>&#160;</td>
          <td class="paramname"><em>eMBPTCPClientConnectedFN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new listening server on address <code>usTCPPort</code> which accepts connection for the addresses specificed in <code>pcBindAddress</code>. </p>
<p>The exact meaning of <code>pcBindAddress</code> is application and platform dependent and therefore not further specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pxTCPHdl</td><td>If a new listening server has been created this handle should point to the server. </td></tr>
    <tr><td class="paramname">pcBindAddress</td><td>The address to bind to. The exact meaning is port dependent. </td></tr>
    <tr><td class="paramname">usTCPPort</td><td>The TCP port. </td></tr>
    <tr><td class="paramname">xMBHdl</td><td>A handle which is used for the callback functions to identify the stack. </td></tr>
    <tr><td class="paramname">eMBPTCPClientNewDataFN</td><td>Callback function if new client data is available. </td></tr>
    <tr><td class="paramname">eMBPTCPClientDisconnectedFN</td><td>Callback function if a client connection is broken. </td></tr>
    <tr><td class="paramname">eMBPTCPClientConnectedFN</td><td>Callback function if a client connects to the server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if a new server was created. In case of invalid arguments it should return eMBErrorCode::MB_EINVAL. Otherwise eMBErrorCode::MB_EPORTERR. </dd></dl>

</div>
</div>
<a id="gacda6ffb210a2e61b5552a54ca21d33ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacda6ffb210a2e61b5552a54ca21d33ed">&#9670;&nbsp;</a></span>eMBTCPServerClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mb__cmn.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBTCPServerClose </td>
          <td>(</td>
          <td class="paramtype">xMBPTCPHandle&#160;</td>
          <td class="paramname"><em>xTCPHdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes a server instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTCPHdl</td><td>A handle for a TCP server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eMBErrorCode::MB_ENOERR if the server has shut down (and closed all client connections). eMBErrorCode::MB_EINVAL if the handle was not valid. All other errors should be mapped to eMBErrorCode::MB_EPORTERR. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
