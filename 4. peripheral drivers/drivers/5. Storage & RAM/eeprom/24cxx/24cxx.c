/*
 * File : 24cxx.c
 * 
 * This file is part of eeprom device for 24cxx,such as at24c02/at24c16.
 * COPYRIGHT (C) 2016
 *
 * Change Logs:
 * Date           Author       Version      Notes
 * 2018-09-01     Acuity        1.00    first version.
 * 2020-04-20     Acuity        1.01    i2c总线提取出去.
 * 2023-01-12     zjcszn        2.00    
 * Note:
 * 
 */
 
#include "24cxx.h"  

#if _24CXX_USE_LOG
#include <stdio.h>
#define _24CXX_LOG(...)         printf(__VA_ARGS__)
#else
#define _24CXX_LOG(...)         ((void)0U)
#endif


#if _24CXX_USE_ASSERT
#include <assert.h>
#define _24CXX_ASSERT(exp)      assert(exp)
#else
#define _24CXX_ASSERT(exp)      ((void)0U)
#endif


/* Private function declaration ----------------------------------------------*/


static uint16_t get_eeprom_pagesize(_24cxx_model_t model);
static uint32_t get_eeprom_chipsize(_24cxx_model_t model);
static int16_t  _24cxx_param_check(_24cxx_dev_t *pdev, uint32_t addr, uint8_t *pbuf, uint32_t size);
static int16_t  _24cxx_write_handler(_24cxx_dev_t *pdev, uint32_t addr, uint8_t *pbuf, uint32_t size);




/* Exported function definition ----------------------------------------------*/

/**
 * @brief  write data to eeprom.
 * @param  pdev pointer to the eeprom device struct.
 * @param  addr the address of write to.
 * @param  pbuf the data to write.
 * @param  size number of bytes to write..
 * @retval return 0 if 0k,anything else is considered an error.
 */
int16_t _24cxx_write(_24cxx_dev_t *pdev, uint32_t addr, uint8_t *pbuf, uint32_t size)
{
  if (_24cxx_param_check(pdev, addr, pbuf, size) != _24CXX_OK)
  {
    return _24CXX_ERR_PARAM_INVALID;
  }
  
  if (pdev->type == _24CXX_FRAM)
  {/* FRAM */
    if (_24cxx_write_handler(pdev, addr, pbuf, size) != _24CXX_OK) 
    {
      return _24CXX_ERR_WRITE_FAILED;
    }
  }
  else
  {/* EEPROM */
    uint16_t write_len;
    uint16_t page_size;
    uint16_t page_remain;

    page_size = get_eeprom_pagesize(pdev->model);
    while (size > 0)
    {
      page_remain = page_size - (addr % page_size);
      write_len   = size > page_remain ? page_remain : size;
      if (_24cxx_write_handler(pdev, addr, pbuf, write_len) != _24CXX_OK)
      {
        return _24CXX_ERR_WRITE_FAILED;
      }
      size -= write_len;
      pbuf += write_len;
      addr += write_len;
      if (pdev->page_write_delay) 
      {
        pdev->page_write_delay();    /*eeprom need wait*/
      }
    }
  }
  return _24CXX_OK;
}

/**
 * @brief  read from the eeprom.
 * @param  pdev pointer to the eeprom device struct.
 * @param  addr the address to read from.
 * @param  pbuf where to put read data.
 * @param  size number of bytes to read.
 * @retval return 0 if 0k,anything else is considered an error.
 */
int16_t _24cxx_read(_24cxx_dev_t *pdev,uint32_t addr, uint8_t *pbuf, uint32_t size)
{  
  if (_24cxx_param_check(pdev, addr, pbuf, size) != _24CXX_OK)
  {
    return _24CXX_ERR_PARAM_INVALID;
  }

  uint8_t  dev_addr = 0;
  uint32_t mem_addr = 0;
  uint32_t mem_addr_len = 0;
  
  if (pdev->model > _24C16)
  {/*24c32-24c2048*/
    dev_addr = pdev->dev_addr | ((addr >> 16) & 0x7);
    mem_addr = addr & 0xFFFF;
    mem_addr_len = 2;
  }
  else
  {/*24c01-24c16*/
    dev_addr = pdev->dev_addr | ((addr >>  8) & 0x7);
    mem_addr = addr & 0xFF;
    mem_addr_len = 1;
  }
  
  if (pdev->i2c_mem_read(dev_addr, mem_addr, mem_addr_len, pbuf, size) != _24CXX_OK)
  {
    _24CXX_LOG("24CXX Error: Read Failed\r\n");
    return _24CXX_ERR_READ_FAILED;
  }
  
  return _24CXX_OK;
}

/**
 * @brief  erase the eeprom.
 * @param  pdev pointer to the eeprom device struct.
 * @param  addr the address to erase from.
 * @param  data padding data.
 * @param  size number of bytes to erase.
 * @retval return 0 if ok,anything else is considered an error.
 */
int16_t _24cxx_erase(_24cxx_dev_t *pdev,uint32_t addr, uint8_t data, uint32_t size)
{

  if (_24cxx_param_check(pdev, addr, &data, size) != _24CXX_OK)
  {
    return _24CXX_ERR_PARAM_INVALID;
  }

  for (int i = 0; i < size; i++, addr++)
  {
    if (_24cxx_write_handler(pdev, addr, &data, 1) != _24CXX_OK)
    {
      _24CXX_LOG("24CXX Error: Erase Failed\r\n");
      return _24CXX_ERR_ERASE_FAILED;
    }
    if (pdev->type == _24CXX_EEPROM && pdev->page_write_delay)
    {
      pdev->page_write_delay();
    }
  }
        
  return _24CXX_OK;
}

/**
 * @brief compare eeprom data and buffer data
 * 
 * @param pdev pointer to the eeprom device struct.
 * @param addr the address of write to.
 * @param pbuf the data to write.
 * @param size number of bytes to write..
 * @return int16_t return 0 if ok,anything else is considered an error.
 */
int16_t _24cxx_compare(_24cxx_dev_t *pdev, uint32_t addr, uint8_t *pbuf, uint32_t size)
{
  if (_24cxx_param_check(pdev, addr, pbuf, size) != _24CXX_OK)
  {
    return _24CXX_ERR_PARAM_INVALID;
  }

  uint8_t tmp;
  /* check write success */
  for (int i = 0; i < size; i++, addr++, pbuf++) 
  {
    if (_24cxx_read(pdev, addr, &tmp, 1) != _24CXX_OK)
    {
      return _24CXX_ERR_READ_FAILED;
    }
    if (*pbuf != tmp)
    {
      _24CXX_LOG("24CXX Error: Compare Failed\r\n");
      return _24CXX_ERR_COMPARE_FAILED;
    } 
  }
  return _24CXX_OK;
}

/* Private function definition -----------------------------------------------*/

/**
 * @brief  get page size
 * @param  model:eeprom model
 * @retval page size
 */  
static uint16_t get_eeprom_pagesize(_24cxx_model_t model) 
{
  switch(model)
  {
    case _24C01:
    case _24C02:
      return 8;
      
    case _24C04:
    case _24C08:
    case _24C16:
      return 16;
      
    case _24C32:
    case _24C64:
      return 32;
        
    case _24C128:
    case _24C256:
      return 64;

    case _24C512:
      return 128;

    case _24C1024:
      return 256;
      
    default:
      return 0;
  }
}

/**
 * @brief  get chip size
 * @param  model:eeprom model
 * @retval chip size,uinit:byte 
 */  
static uint32_t get_eeprom_chipsize(_24cxx_model_t model) 
{
  switch(model)
  {
    case _24C01:
      return 128U;
    case _24C02:
      return 256U;
    case _24C04:
      return 512U;
    case _24C08:
      return 1024U;
    case _24C16:
      return 2048U;
    case _24C32:
      return 4096U;
    case _24C64:
      return 8192U;
    case _24C128:
      return 16384U;
    case _24C256:
      return 32768U;
    case _24C512:
      return 65536U;
    case _24C1024:
      return 131072U;
    default:
      return 0U;
  }
}

/**
 * @brief  write operating function. 
 * @param  pdev pointer to the eeprom device struct.
 * @param  addr the address of write to.
 * @param  pbuf the data to write.
 * @param  size number of bytes to write..
 * @retval return 0 if 0k,anything else is considered an error.
 */
static int16_t _24cxx_write_handler(_24cxx_dev_t *pdev, uint32_t addr, uint8_t *pbuf, uint32_t size)
{
  uint8_t  dev_addr = 0;
  uint32_t mem_addr = 0;
  uint32_t mem_addr_len = 0;

  #if _24CXX_CHECK_PAGE_OVERFLOW
  uint16_t page_size = get_eeprom_pagesize(pdev->model);
  if (pdev->type == _24CXX_EEPROM)
  {
    if (((addr % page_size) + size) > page_size)
    {
      _24CXX_LOG("24CXX Error: Addr:0x%X, Size:%u --> Page Overflow\r\n", addr, size);
      return _24CXX_ERR_PAGE_OVERFLOW;
    }
  }
  #endif
  
  if (pdev->model > _24C16)
  {/*24c32-24c2048*/
    dev_addr = pdev->dev_addr | ((addr >> 16) & 0x7);
    mem_addr = addr & 0xFFFF;
    mem_addr_len = 2;
  }
  else
  {/*24c01-24c16*/
    dev_addr = pdev->dev_addr | ((addr >>  8) & 0x7);
    mem_addr = addr & 0xFF;
    mem_addr_len = 1;
  }
  
  if (pdev->wp)   /*release write protect*/
  {
    pdev->wp(0);
  }
  
  if (pdev->i2c_mem_write(dev_addr, mem_addr, mem_addr_len, pbuf, size) != _24CXX_OK)
  {
    _24CXX_LOG("24CXX Error: Write Failed\r\n");
    return _24CXX_ERR_WRITE_FAILED;
  }
  
  if (pdev->wp)
  {
    pdev->wp(1);  /*write protect*/
  }
  
  return _24CXX_OK;
}

/**
 * @brief check param function
 * 
 * @param  pdev pointer to the eeprom device struct.
 * @param  addr the address of write to.
 * @param  pbuf the data to write.
 * @param  size number of bytes to write or read..
 * @return int16_t return 0 if 0k,anything else is considered an error.
 */
static int16_t _24cxx_param_check(_24cxx_dev_t *pdev, uint32_t addr, uint8_t *pbuf, uint32_t size) {

  /* check validty of param */
  #if _24CXX_CHECK_PARAM
  if (!pdev) 
  {
    _24CXX_LOG("24CXX Param Error: Device Handle NULL\r\n");
    return _24CXX_ERR_PARAM_DEVICE;
  }
  if (!pdev->i2c_mem_write || !pdev->i2c_mem_read) 
  {
    _24CXX_LOG("24CXX Param Error: Write or Read Function Not Definition\r\n");
    return _24CXX_ERR_PARAM_DEVICE;
  }
  if (pdev->type == _24CXX_EEPROM && !pdev->page_write_delay)
  {
    _24CXX_LOG("24CXX Param Error: EEPROM Write Delay Function Not Definition\r\n");
    return _24CXX_ERR_PARAM_DEVICE;
  }
  if (addr >= get_eeprom_chipsize(pdev->model)) 
  {
    _24CXX_LOG("24CXX Param Error: Address Out of Bounds\r\n");
    return _24CXX_ERR_PARAM_MEMADDR;
  }
  if (size >  get_eeprom_chipsize(pdev->model)) 
  {
    _24CXX_LOG("24CXX Param Error: Length Out of Bounds\r\n");
    return _24CXX_ERR_PARAM_LENGTH;
  }
  if (!pbuf) 
  {
    _24CXX_LOG("24CXX Param Error: Data Buffer NULL\r\n");
    return _24CXX_ERR_PARAM_BUFFER;
  }
  #endif

  /* check overflow on the write or read operation */
  #if _24CXX_CHECK_CHIP_OVERFLOW
  if ((addr + size) > get_eeprom_chipsize(pdev->model))  /*the over flow of chip size*/
  {
    _24CXX_LOG("24CXX Error: Addr:0x%X, Size:%u --> Chip Overflow\r\n", addr, size);
    return _24CXX_ERR_CHIP_OVERFLOW;
  }
  #endif

  return _24CXX_OK;
}

/* Test function declaration -------------------------------------------------*/


#if _24CXX_USE_TEST

#include "bsp_i2c_sw.h"

/* private variables */
static soft_i2c_dev_t dev_test_i2c = {0};
static _24cxx_dev_t   dev_test_eep = {0};

/* test dummy data */
static uint8_t dummy_data []= 
{
0xC9, 0x22, 0x16, 0x66, 0xE6, 0xE8, 0x8C, 0x97, 0xF4, 0x30, 0xC5, 0x39, 0xF9, 0x63, 0x23, 0x71, 
0x48, 0x7E, 0x83, 0x0A, 0xE7, 0x54, 0xB6, 0xBC, 0xEC, 0x0F, 0xCA, 0x46, 0x13, 0x35, 0x61, 0x2B, 
0x98, 0xCE, 0x5B, 0x0A, 0xBB, 0x29, 0x2C, 0xEE, 0x5A, 0xF3, 0xFB, 0xBB, 0x0F, 0x71, 0x55, 0xD6, 
0xAD, 0x7D, 0xA5, 0x4D, 0xC0, 0x09, 0x73, 0xE8, 0xE5, 0xE7, 0x9E, 0x04, 0xCF, 0x19, 0xF8, 0x55, 
0x2B, 0x49, 0x5D, 0x99, 0x62, 0x7C, 0xBD, 0x9E, 0x5B, 0x83, 0xCB, 0x4A, 0x4A, 0xA0, 0xC6, 0xC4, 
0x2E, 0xA9, 0x02, 0x34, 0x27, 0xDE, 0x14, 0x59, 0x75, 0x93, 0xCF, 0xFA, 0x06, 0xF6, 0xD0, 0x9C, 
0xC8, 0x0D, 0xC4, 0xF6, 0xB3, 0x38, 0xB9, 0x4B, 0xF4, 0xEC, 0xA0, 0x0D, 0xF7, 0x99, 0x4C, 0x48, 
0x51, 0xA8, 0x24, 0xAD, 0x0C, 0xDC, 0x60, 0xAF, 0x7C, 0x78, 0x66, 0xD7, 0xE8, 0x46, 0x90, 0x1D, 
0x4A, 0x70, 0x29, 0xDB, 0xB0, 0x9A, 0x50, 0xCE, 0x69, 0x83, 0x4C, 0xD6, 0x68, 0x08, 0x68, 0x7C, 
0x33, 0x4B, 0xAC, 0xA3, 0x47, 0x24, 0xDC, 0x10, 0x07, 0x81, 0xFC, 0x73, 0x85, 0x85, 0x93, 0x29, 
0x86, 0xCE, 0xA4, 0xC5, 0x4A, 0xA2, 0x9B, 0xF7, 0x73, 0x32, 0x9E, 0x99, 0xED, 0x4F, 0xC5, 0x61, 
0x74, 0x91, 0x27, 0xF8, 0xFA, 0x37, 0x06, 0xF0, 0xA1, 0x90, 0x18, 0x11, 0x88, 0x9A, 0x81, 0xCA, 
0x12, 0xB5, 0xA1, 0x31, 0x49, 0xB9, 0x71, 0xCC, 0x3D, 0xAE, 0x86, 0x41, 0x6F, 0x67, 0xBC, 0x38, 
0xA6, 0x1C, 0xD8, 0xD8, 0x8A, 0x66, 0x39, 0x49, 0x2D, 0xEE, 0xE6, 0xB5, 0x7D, 0x81, 0xD9, 0x60, 
0x7B, 0xCC, 0x02, 0x98, 0x7B, 0x1F, 0x07, 0xA7, 0x2B, 0xC9, 0x86, 0x42, 0x3E, 0x0B, 0x1B, 0x02, 
0xD0, 0x5B, 0x03, 0x6E, 0x33, 0x34, 0xDA, 0xEC, 0xA6, 0xB3, 0x0F, 0xEB, 0x71, 0x68, 0xE8, 0x02, 
0xC7, 0xA1, 0x2B, 0x7D, 0x74, 0xA5, 0x1F, 0xD2, 0x8E, 0x8D, 0x15, 0x84, 0xA8, 0x32, 0x1E, 0xF6, 
0x9B, 0xF9, 0x86, 0xD3, 0x81, 0xE8, 0x98, 0x5A, 0xF3, 0x01, 0xE1, 0x9E, 0x93, 0x01, 0xCB, 0xB5, 
0x8E, 0x9F, 0xB3, 0xCE, 0xFC, 0x51, 0x80, 0x03, 0x8D, 0xB1, 0x0F, 0xC8, 0x2B, 0xC0, 0xAB, 0x81, 
0x02, 0xFB, 0xA9, 0x8F, 0xAF, 0x03, 0x40, 0x2D, 0x17, 0x3C, 0x9E, 0x11, 0xBA, 0x36, 0x38, 0x12, 
0xCD, 0x8D, 0x91, 0x36, 0x56, 0x3B, 0xE8, 0x02, 0xCD, 0x87, 0x64, 0xFB, 0x6A, 0x35, 0x9E, 0x74, 
0xA1, 0x2E, 0x7E, 0x0F, 0xF4, 0x7E, 0x7F, 0xD6, 0x03, 0x2D, 0x80, 0xB9, 0x29, 0x7E, 0x71, 0xA6, 
0x2E, 0x37, 0x1A, 0xEB, 0xED, 0xDD, 0xF0, 0xE5, 0x53, 0xE1, 0x6A, 0x07, 0x13, 0xF4, 0x6E, 0xB4, 
0xA2, 0xF2, 0x22, 0x1B, 0xDE, 0x5C, 0x32, 0xE9, 0x37, 0x26, 0xAF, 0x96, 0xCB, 0xC4, 0x9F, 0x97, 
0x70, 0xF3, 0x06, 0x2C, 0xE5, 0x8E, 0x7E, 0x15, 0x15, 0x45, 0x86, 0x29, 0xDF, 0x7B, 0x7E, 0x8E, 
0x56, 0x43, 0x4E, 0x17, 0x71, 0x57, 0x1D, 0xF4, 0x5E, 0x5A, 0x62, 0xA3, 0x3B, 0xAE, 0x2A, 0x30, 
0xFC, 0x02, 0xC2, 0xFB, 0x9A, 0x56, 0xBD, 0xCE, 0xE5, 0x4B, 0x07, 0xFA, 0xF5, 0x78, 0x7D, 0x48, 
0x81, 0x47, 0xCB, 0x20, 0x1B, 0x64, 0x79, 0xC9, 0x33, 0x30, 0xB6, 0xD0, 0x59, 0x2A, 0x29, 0xF7, 
0xEE, 0xD2, 0xAF, 0x78, 0xAD, 0x0C, 0xC7, 0xF2, 0x48, 0xFD, 0x85, 0x51, 0xE9, 0xAB, 0xCF, 0x86, 
0x99, 0x88, 0x80, 0x3E, 0x38, 0xB4, 0x51, 0x2B, 0x2C, 0xF7, 0xF9, 0x1D, 0x40, 0xDA, 0xB4, 0xE5, 
0x42, 0x89, 0x4D, 0xB5, 0x05, 0xC8, 0x41, 0x5B, 0xDE, 0x67, 0x79, 0xF3, 0x84, 0xEB, 0xB0, 0x66, 
0xF1, 0xF8, 0x26, 0x56, 0xF5, 0x8E, 0xD2, 0xF6, 0x78, 0x19, 0x13, 0xC6, 0x12, 0x61, 0x02, 0x00, 
0x4C, 0x9A, 0x4B, 0x09, 0xD9, 0xF2, 0x14, 0xCC, 0xD4, 0xBB, 0xBC, 0x83, 0x75, 0x80, 0xCD, 0xAA, 
0x25, 0x46, 0x2C, 0x53, 0x6B, 0x73, 0xB2, 0x08, 0xCD, 0x4D, 0x52, 0xC8, 0x51, 0x21, 0x96, 0x94, 
0xB5, 0x02, 0xAE, 0x9D, 0xC7, 0x19, 0xD0, 0x6A, 0x26, 0x7F, 0x0F, 0x64, 0x40, 0xB7, 0x74, 0xC2, 
0xB4, 0xD8, 0xFE, 0xE1, 0x3E, 0xC5, 0x3E, 0x1A, 0x21, 0x1C, 0x86, 0x91, 0x50, 0xF2, 0x51, 0x39, 
0xAD, 0x29, 0x54, 0xC8, 0x31, 0xB5, 0x04, 0x64, 0x09, 0xFC, 0x22, 0x4E, 0x4E, 0x88, 0x4E, 0x1D, 
0x0D, 0x4E, 0xC7, 0xD6, 0x88, 0x4F, 0x4D, 0xB0, 0x1E, 0x1B, 0x02, 0x0A, 0xAE, 0xB1, 0xD5, 0xB9, 
0xBB, 0xC0, 0xE1, 0xC0, 0xA7, 0xC0, 0xFD, 0xCB, 0xF9, 0x69, 0x66, 0x38, 0x23, 0x78, 0xF7, 0x10, 
0x26, 0x2E, 0x94, 0xC4, 0xD2, 0x25, 0x3A, 0x9C, 0x5B, 0xDF, 0x0C, 0xB4, 0xDB, 0x93, 0x89, 0xB8, 
0x32, 0xCB, 0x93, 0x53, 0xEB, 0x2C, 0xD4, 0xCF, 0x73, 0xBC, 0x41, 0x4C, 0x8A, 0xB0, 0x77, 0xC1, 
0xDB, 0xBA, 0x5E, 0x64, 0xD4, 0x08, 0x54, 0xD6, 0x03, 0x46, 0xF3, 0x04, 0x83, 0xD1, 0xF5, 0x25, 
0x11, 0xA4, 0x0F, 0xEF, 0x64, 0x22, 0x86, 0xA0, 0x5D, 0x7A, 0x62, 0x4A, 0x9B, 0x86, 0x69, 0x09, 
0xD8, 0x36, 0x17, 0x88, 0x1D, 0x37, 0xE6, 0x49, 0xA0, 0x05, 0x6D, 0x33, 0x7E, 0xE9, 0x89, 0xE1, 
0x88, 0x55, 0x9A, 0xBE, 0x57, 0x04, 0xBC, 0x65, 0x91, 0xAF, 0x29, 0x86, 0xB4, 0x02, 0x2E, 0xCC, 
0x37, 0xEB, 0x32, 0xD4, 0x81, 0x97, 0x0D, 0x00, 0x06, 0x5A, 0x49, 0x67, 0xB7, 0x69, 0x30, 0x1A, 
0x9B, 0xC1, 0x12, 0x75, 0x93, 0xAA, 0xA9, 0x97, 0x55, 0x41, 0x25, 0x6E, 0x10, 0x58, 0xA4, 0xA0, 
0x84, 0xA5, 0x8C, 0xEA, 0xEA, 0xA1, 0x25, 0x5D, 0x8C, 0xE8, 0xDE, 0xE9, 0x1D, 0xD1, 0x43, 0xC3, 
0x67, 0x17, 0x3E, 0x51, 0x21, 0x08, 0x51, 0x3C, 0xC3, 0x8A, 0xAC, 0xE0, 0x2C, 0x1A, 0x2D, 0x3E, 
0xF8, 0xEB, 0x88, 0x15, 0x7F, 0x69, 0x0E, 0xB2, 0x4C, 0xA2, 0xE1, 0x3A, 0x63, 0xE8, 0xBF, 0x90, 
0x6A, 0xAF, 0xF0, 0x61, 0x9A, 0xDA, 0x82, 0xF3, 0x98, 0xDE, 0x26, 0xB2, 0x87, 0x53, 0x0A, 0xCB, 
0x08, 0xFD, 0x7E, 0x95, 0xC3, 0x81, 0x3F, 0x70, 0x84, 0x13, 0xCC, 0x57, 0xDE, 0xD1, 0xB9, 0x89, 
0x09, 0x9F, 0x90, 0xC5, 0x57, 0xC7, 0x8D, 0x49, 0x77, 0xCF, 0xE8, 0xA8, 0x1D, 0xE8, 0xAD, 0x32, 
0x4B, 0x5A, 0xAD, 0xE2, 0x62, 0xD8, 0x51, 0x46, 0x4E, 0x1F, 0x96, 0x6A, 0xF1, 0x26, 0x36, 0x56, 
0xC2, 0x1F, 0x1B, 0x56, 0x32, 0x97, 0x08, 0x7D, 0x61, 0x4D, 0x73, 0xDD, 0x61, 0x4E, 0xCB, 0xE6, 
0x04, 0xB1, 0x27, 0x2C, 0x50, 0xCE, 0x76, 0xAD, 0x65, 0xB5, 0xCD, 0x37, 0x29, 0xC4, 0xE7, 0x64, 
0xE8, 0x59, 0xAA, 0xA9, 0x32, 0xE7, 0x18, 0xCE, 0x89, 0x6A, 0x40, 0x90, 0x24, 0x57, 0x58, 0x1A, 
0xC0, 0xC7, 0xCA, 0xAE, 0x1A, 0x67, 0x1C, 0xDE, 0xB4, 0x7A, 0xCD, 0xA1, 0xD0, 0xB4, 0xFA, 0x32, 
0x51, 0x7D, 0xF6, 0xE3, 0xBD, 0xAA, 0x9E, 0x53, 0x49, 0x49, 0x9B, 0xA6, 0xBB, 0xB7, 0x8D, 0x81, 
0x94, 0x78, 0x64, 0x90, 0xB1, 0xB2, 0x0F, 0x27, 0xAF, 0xFB, 0xE7, 0x99, 0xE3, 0xC4, 0x54, 0x79, 
0x13, 0x51, 0x25, 0x1E, 0xC5, 0x3E, 0x97, 0x87, 0x44, 0x74, 0xBE, 0xE8, 0xBB, 0x63, 0x32, 0x57, 
0x78, 0xF0, 0x5F, 0x4E, 0xC0, 0x72, 0x80, 0x6E, 0x39, 0x57, 0xE4, 0xA4, 0x62, 0x2A, 0x2A, 0x1C, 
0xC1, 0x33, 0x68, 0x52, 0x4E, 0x0D, 0xD5, 0x6B, 0x03, 0x9C, 0xD2, 0xAE, 0x49, 0x8F, 0x26, 0x5F, 
0x9E, 0x9F, 0x48, 0xD2, 0xB9, 0xA6, 0x97, 0xED, 0x06, 0x64, 0x29, 0x07, 0xCD, 0x0D, 0x08, 0x17, 
};

/* eeprom i2c write function */
static int dev_test_i2c_write(uint8_t dev_addr, uint16_t mem_addr, uint16_t addr_size, const void *send_buff, uint32_t send_size)
{
  dev_test_i2c.dev_addr = dev_addr;
  if (soft_i2c_master_mem_write(&dev_test_i2c, mem_addr, addr_size, send_buff, send_size) != SOFT_I2C_OK)
  {
    return _24CXX_ERR_TRANS_FAILED;
  }
  else
  {
    return _24CXX_OK;
  }
}

/* eeprom i2c read function */
static int dev_test_i2c_read(uint8_t dev_addr, uint16_t mem_addr, uint16_t addr_size, void *recv_buff, uint32_t recv_size)
{
  dev_test_i2c.dev_addr = dev_addr;
  if (soft_i2c_master_mem_read(&dev_test_i2c, mem_addr, addr_size, recv_buff, recv_size) != SOFT_I2C_OK)
  {
    return _24CXX_ERR_TRANS_FAILED;
  }
  else
  {
    return _24CXX_OK;
  }
}

/* eeprom i2c write delay function */
static void dev_test_wr_delay(void) 
{
  HAL_Delay(_24CXX_WRITE_DELAY);
}

/* eeprom i2c write protection function */
static void dev_test_wp(uint8_t ctrl)
{
  // TO DO
}

/* eeprom driver test function */
int16_t _24cxx_test(void)
{
  /* i2c and eeprom device init */
  dev_test_i2c.scl.port = _24CXX_DEMO_SCL_PORT;
  dev_test_i2c.scl.pin  = _24CXX_DEMO_SCL_PIN;
  dev_test_i2c.sda.port = _24CXX_DEMO_SDA_PORT;
  dev_test_i2c.sda.pin  = _24CXX_DEMO_SDA_PIN;
  dev_test_i2c.dev_addr = _24CXX_DEMO_ADDR;
  
  soft_i2c_init(&dev_test_i2c, 400);

  dev_test_eep.type     = _24CXX_DEMO_TYPE;
  dev_test_eep.model    = _24CXX_DEMO_MODEL;
  dev_test_eep.dev_addr = _24CXX_DEMO_ADDR;
  
  dev_test_eep.wp               = dev_test_wp;
  dev_test_eep.i2c_mem_read     = dev_test_i2c_read;
  dev_test_eep.i2c_mem_write    = dev_test_i2c_write;
  dev_test_eep.page_write_delay = dev_test_wr_delay;
  
  printf("24CXX EEPROM Driver Test Start--------------\r\n\r\n");

  /* write eeprom test */

  if (_24cxx_write(&dev_test_eep, 0, dummy_data, 1024) != _24CXX_OK)
  {
    printf("EEPROM Write Failed\r\n");
    return _24CXX_ERR_WRITE_FAILED;
  }
  else 
  {
    printf("EEPROM Write Success\r\n");
  }

  if (_24cxx_compare(&dev_test_eep, 0, dummy_data, 1024) != _24CXX_OK)
  {
    printf("EEPROM Write Compare Failed\r\n");
    return _24CXX_ERR_COMPARE_FAILED;
  }
  else
  {
    printf("EEPROM Write Compare Success\r\n");
  }

  /* erase eeprom test */

  if (_24cxx_erase(&dev_test_eep, 0, 0XFF, 1024) != _24CXX_OK)
  {
    printf("EEPROM Erase Failed\r\n");
    return _24CXX_ERR_WRITE_FAILED;
  }
  else 
  {
    printf("EEPROM Erase Success\r\n");
  }

  uint8_t recv_tmp;
  for (int i = 0; i < 1024; i++) 
  {
    if (_24cxx_read(&dev_test_eep, i, &recv_tmp, 1) != _24CXX_OK)
    {
      printf("EEPROM Read Failed\r\n");
      return _24CXX_ERR_READ_FAILED;
    }
    if (recv_tmp != 0XFF)
    {
      printf("EEPROM Erase Compare Failed\r\n");
      return _24CXX_ERR_COMPARE_FAILED;
    }
  }
  printf("EEPROM Erase Compare Success\r\n\r\n");

  printf("24CXX EEPROM Driver Test End ----------------\r\n");

  return _24CXX_OK;
}



#endif

